# ç¬¬15ç« æ¦‚å¿µå®Ÿè¨¼ã‚³ãƒ¼ãƒ‰é…ç½®ãƒ»é‡è©•ä¾¡ï¼šå­¦ç¿’åŠ¹æœæœ€å¤§åŒ–è¨­è¨ˆ

## ğŸ“Š æ¦‚å¿µå®Ÿè¨¼ã‚³ãƒ¼ãƒ‰ã®æˆ¦ç•¥çš„å½¹å‰²åˆ†æ

### **ç†è«–ã¨å®Ÿè£…ã®æ©‹æ¸¡ã—æ©Ÿèƒ½**

**æ®µéšçš„ç†è§£ä¿ƒé€²**:
- **ç†è«–èª¬æ˜**: æ¦‚å¿µãƒ»åŸç†ã®èª¬æ˜ï¼ˆæœ¬æ–‡ï¼‰
- **æ¦‚å¿µå®Ÿè¨¼**: åŸºæœ¬æ©Ÿèƒ½ã®å‹•ä½œç¢ºèªï¼ˆæ¦‚å¿µå®Ÿè¨¼ã‚³ãƒ¼ãƒ‰ï¼‰
- **å®Ÿç”¨å®Ÿè£…**: å®Ÿéš›ã®æ¥­å‹™ã§ä½¿ç”¨å¯èƒ½ï¼ˆå®Œå…¨å®Ÿè£…ã‚³ãƒ¼ãƒ‰ï¼‰
- **çµ±åˆæ¤œè¨¼**: ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã§ã®å‹•ä½œç¢ºèªï¼ˆçµ±åˆãƒ†ã‚¹ãƒˆï¼‰

**èª­è€…å±¤åˆ¥å­¦ç¿’æ”¯æ´**:
- **ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢**: å®Ÿè£…æŠ€è¡“ã®æ®µéšçš„ç¿’å¾—
- **BA**: æŠ€è¡“çš„å®Ÿç¾å¯èƒ½æ€§ã®ç†è§£
- **ãƒãƒ¼ã‚±ãƒƒã‚¿ãƒ¼**: æŠ€è¡“çš„ä¾¡å€¤ã®å…·ä½“çš„æŠŠæ¡
- **çµŒå–¶è€…**: æŠ•è³‡å¯¾åŠ¹æœã®æŠ€è¡“çš„æ ¹æ‹ ç†è§£

### **æ¦‚å¿µå®Ÿè¨¼ã‚³ãƒ¼ãƒ‰ã®å“è³ªè¦ä»¶**

**æŠ€è¡“çš„è¦ä»¶**:
- **å‹•ä½œå¯èƒ½æ€§**: å®Ÿéš›ã«å®Ÿè¡Œå¯èƒ½ãªã‚³ãƒ¼ãƒ‰
- **æ•™è‚²åŠ¹æœ**: å­¦ç¿’ç›®æ¨™ã«å¯¾ã™ã‚‹åŠ¹æœçš„ãªå®Ÿè£…ä¾‹
- **ç°¡æ½”æ€§**: 20-32è¡Œã§ã®æ ¸å¿ƒæ©Ÿèƒ½å®Ÿè£…
- **æ‹¡å¼µæ€§**: å®Œå…¨å®Ÿè£…ã¸ã®ç™ºå±•å¯èƒ½æ€§

**å†…å®¹çš„è¦ä»¶**:
- **ç›®çš„æ˜ç¢ºæ€§**: å„ã‚³ãƒ¼ãƒ‰ã®å­¦ç¿’ç›®æ¨™ãŒæ˜ç¢º
- **ç‹¬ç«‹æ€§**: å˜ç‹¬ã§ç†è§£ãƒ»å®Ÿè¡Œå¯èƒ½
- **é–¢é€£æ€§**: ã‚»ã‚¯ã‚·ãƒ§ãƒ³å†…å®¹ã¨ã®å¯†æ¥ãªé–¢é€£
- **å®Ÿç”¨æ€§**: å®Ÿéš›ã®æ¥­å‹™ã§ã®å¿œç”¨å¯èƒ½æ€§

## ğŸ“‹ ã‚»ã‚¯ã‚·ãƒ§ãƒ³åˆ¥æ¦‚å¿µå®Ÿè¨¼ã‚³ãƒ¼ãƒ‰è©³ç´°è¨­è¨ˆ

### **15.1 å¤šæ§˜ãªãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹æ¥ç¶š** (12å€‹)

#### **15.1.1 3è¦–ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹ã®æˆ¦ç•¥çš„ä¾¡å€¤** (3å€‹)

**Code-15-1-1-A: 3è¦–ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹å®šç¾©ã¨ãƒãƒƒãƒ”ãƒ³ã‚°** (20è¡Œ)
```typescript
// ç›®çš„: 3è¦–ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹ã®æ§‹é€ åŒ–å®šç¾©ã¨æˆ¦ç•¥çš„ä¾¡å€¤ã®å¯è¦–åŒ–
interface PerspectiveDataSource {
  perspective: 'technology' | 'market' | 'business';
  sources: DataSourceConfig[];
  priority: number;
  updateFrequency: string;
  qualityRequirements: QualityMetrics;
}

const tripleDataSources: PerspectiveDataSource[] = [
  {
    perspective: 'technology',
    sources: [
      { type: 'api', endpoint: 'patents-api', weight: 0.8 },
      { type: 'database', connection: 'tech-trends-db', weight: 0.9 }
    ],
    priority: 1,
    updateFrequency: 'realtime',
    qualityRequirements: { accuracy: 0.95, completeness: 0.90 }
  }
  // ä»–ã®è¦–ç‚¹ã®å®šç¾©...
];
```

**å­¦ç¿’ç›®æ¨™**: 3è¦–ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹ã®æ§‹é€ åŒ–å®šç¾©æ‰‹æ³•
**å®Ÿè£…ä¾¡å€¤**: ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹æˆ¦ç•¥ã®å¯è¦–åŒ–ã¨ç®¡ç†

**Code-15-1-1-B: ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹å„ªå…ˆåº¦è©•ä¾¡ãƒ­ã‚¸ãƒƒã‚¯** (18è¡Œ)
```typescript
// ç›®çš„: ãƒ“ã‚¸ãƒã‚¹ä¾¡å€¤ã«åŸºã¥ããƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹å„ªå…ˆåº¦ã®å‹•çš„è©•ä¾¡
class DataSourcePriorityEvaluator {
  evaluatePriority(source: DataSourceConfig, context: BusinessContext): number {
    const businessValue = this.calculateBusinessValue(source, context);
    const technicalFeasibility = this.assessTechnicalFeasibility(source);
    const costEfficiency = this.calculateCostEfficiency(source);
    
    return (businessValue * 0.5) + (technicalFeasibility * 0.3) + (costEfficiency * 0.2);
  }
  
  private calculateBusinessValue(source: DataSourceConfig, context: BusinessContext): number {
    // æˆ¦ç•¥çš„é‡è¦åº¦ã€ãƒ‡ãƒ¼ã‚¿å“è³ªã€æ›´æ–°é »åº¦ã‚’è€ƒæ…®ã—ãŸä¾¡å€¤è¨ˆç®—
    return (source.strategicImportance * context.urgency * source.dataQuality) / 100;
  }
}
```

**å­¦ç¿’ç›®æ¨™**: ãƒ“ã‚¸ãƒã‚¹ä¾¡å€¤ã«åŸºã¥ãå„ªå…ˆåº¦è©•ä¾¡æ‰‹æ³•
**å®Ÿè£…ä¾¡å€¤**: ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹æŠ•è³‡ã®æœ€é©åŒ–

**Code-15-1-1-C: ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹çµ±åˆæˆ¦ç•¥å®Ÿè£…** (22è¡Œ)
```typescript
// ç›®çš„: 3è¦–ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹ã®åŠ¹ç‡çš„çµ±åˆæˆ¦ç•¥
class DataSourceIntegrationStrategy {
  async integrateTriplePerspectiveSources(sources: PerspectiveDataSource[]): Promise<IntegratedDataSet> {
    const integrationPlan = this.createIntegrationPlan(sources);
    const parallelGroups = this.groupByParallelizability(integrationPlan);
    
    const results = await Promise.all(
      parallelGroups.map(group => this.processSourceGroup(group))
    );
    
    return this.mergeResults(results);
  }
  
  private createIntegrationPlan(sources: PerspectiveDataSource[]): IntegrationPlan {
    // ä¾å­˜é–¢ä¿‚ã€å‡¦ç†é †åºã€ä¸¦åˆ—åŒ–å¯èƒ½æ€§ã‚’è€ƒæ…®ã—ãŸçµ±åˆè¨ˆç”»
    return new IntegrationPlan(sources);
  }
}
```

**å­¦ç¿’ç›®æ¨™**: è¤‡æ•°ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹ã®åŠ¹ç‡çš„çµ±åˆæ‰‹æ³•
**å®Ÿè£…ä¾¡å€¤**: çµ±åˆå‡¦ç†ã®æœ€é©åŒ–ã¨è‡ªå‹•åŒ–

#### **15.1.2 APIæ¥ç¶šã¨RESTfulçµ±åˆ** (3å€‹)

**Code-15-1-2-A: REST APIåŸºæœ¬æ¥ç¶šå®Ÿè£…** (20è¡Œ)
```typescript
// ç›®çš„: å …ç‰¢ãªREST APIæ¥ç¶šã®åŸºæœ¬å®Ÿè£…
class RobustAPIConnector {
  async connectWithRetry(config: APIConfig): Promise<APIResponse> {
    const maxRetries = 3;
    let lastError: Error;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const response = await this.makeRequest(config);
        this.logSuccess(config.endpoint, attempt);
        return response;
      } catch (error) {
        lastError = error;
        await this.waitBeforeRetry(attempt);
      }
    }
    
    throw new APIConnectionError(`Failed after ${maxRetries} attempts`, lastError);
  }
}
```

**å­¦ç¿’ç›®æ¨™**: å …ç‰¢ãªAPIæ¥ç¶šã®å®Ÿè£…æ‰‹æ³•
**å®Ÿè£…ä¾¡å€¤**: ä¿¡é ¼æ€§ã®é«˜ã„ãƒ‡ãƒ¼ã‚¿åé›†åŸºç›¤

**Code-15-1-2-B: OAuthèªè¨¼ä»˜ãAPIå‘¼ã³å‡ºã—** (25è¡Œ)
```typescript
// ç›®çš„: OAuth 2.0èªè¨¼ã‚’å«ã‚€å®‰å…¨ãªAPIå‘¼ã³å‡ºã—
class SecureAPIClient {
  private accessToken: string;
  private refreshToken: string;
  
  async authenticatedRequest(endpoint: string, options: RequestOptions): Promise<any> {
    if (this.isTokenExpired()) {
      await this.refreshAccessToken();
    }
    
    const headers = {
      ...options.headers,
      'Authorization': `Bearer ${this.accessToken}`,
      'Content-Type': 'application/json'
    };
    
    try {
      return await this.makeRequest(endpoint, { ...options, headers });
    } catch (error) {
      if (error.status === 401) {
        await this.refreshAccessToken();
        return await this.makeRequest(endpoint, { ...options, headers });
      }
      throw error;
    }
  }
}
```

**å­¦ç¿’ç›®æ¨™**: OAuthèªè¨¼ã®å®Ÿè£…ã¨ãƒˆãƒ¼ã‚¯ãƒ³ç®¡ç†
**å®Ÿè£…ä¾¡å€¤**: ã‚»ã‚­ãƒ¥ã‚¢ãªAPIé€£æºã®å®Ÿç¾

**Code-15-1-2-C: ãƒ¬ãƒ¼ãƒˆåˆ¶é™ãƒ»ãƒªãƒˆãƒ©ã‚¤æˆ¦ç•¥** (23è¡Œ)
```typescript
// ç›®çš„: API ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã«å¯¾å¿œã—ãŸé©å¿œçš„ãƒªãƒˆãƒ©ã‚¤æˆ¦ç•¥
class AdaptiveRateLimiter {
  private requestQueue: RequestQueue = new RequestQueue();
  private rateLimitInfo: RateLimitInfo = {};
  
  async executeWithRateLimit(request: APIRequest): Promise<APIResponse> {
    await this.waitForRateLimit(request.endpoint);
    
    try {
      const response = await this.executeRequest(request);
      this.updateRateLimitInfo(response.headers);
      return response;
    } catch (error) {
      if (error.status === 429) { // Too Many Requests
        const retryAfter = this.parseRetryAfter(error.headers);
        await this.delay(retryAfter * 1000);
        return await this.executeWithRateLimit(request);
      }
      throw error;
    }
  }
}
```

**å­¦ç¿’ç›®æ¨™**: ãƒ¬ãƒ¼ãƒˆåˆ¶é™å¯¾å¿œã¨ãƒªãƒˆãƒ©ã‚¤æˆ¦ç•¥
**å®Ÿè£…ä¾¡å€¤**: APIåˆ©ç”¨åŠ¹ç‡ã®æœ€å¤§åŒ–

#### **15.1.3 ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹é€£æºã¨ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åŒæœŸ** (3å€‹)

**Code-15-1-3-A: SQL/NoSQLãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶š** (22è¡Œ)
```typescript
// ç›®çš„: ç•°ç¨®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®çµ±ä¸€çš„æ¥ç¶šç®¡ç†
class UnifiedDatabaseConnector {
  private connections: Map<string, DatabaseConnection> = new Map();
  
  async connect(config: DatabaseConfig): Promise<DatabaseConnection> {
    const connectionKey = this.generateConnectionKey(config);
    
    if (this.connections.has(connectionKey)) {
      return this.connections.get(connectionKey);
    }
    
    const connection = await this.createConnection(config);
    await this.validateConnection(connection);
    
    this.connections.set(connectionKey, connection);
    this.setupConnectionMonitoring(connection);
    
    return connection;
  }
  
  async query(connectionKey: string, query: Query): Promise<QueryResult> {
    const connection = this.connections.get(connectionKey);
    return await connection.execute(query);
  }
}
```

**å­¦ç¿’ç›®æ¨™**: ç•°ç¨®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®çµ±ä¸€ç®¡ç†
**å®Ÿè£…ä¾¡å€¤**: ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹é€£æºã®åŠ¹ç‡åŒ–

**Code-15-1-3-B: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åŒæœŸï¼ˆCDCï¼‰å®Ÿè£…** (28è¡Œ)
```typescript
// ç›®çš„: Change Data Capture ã«ã‚ˆã‚‹ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ‡ãƒ¼ã‚¿åŒæœŸ
class ChangeDataCaptureSync {
  private changeStreams: Map<string, ChangeStream> = new Map();
  
  async startCDC(sourceConfig: DatabaseConfig, targetConfig: TargetConfig): Promise<void> {
    const changeStream = await this.createChangeStream(sourceConfig);
    
    changeStream.on('change', async (change: ChangeEvent) => {
      try {
        await this.processChange(change, targetConfig);
        this.logChangeProcessed(change);
      } catch (error) {
        await this.handleChangeError(change, error);
      }
    });
    
    this.changeStreams.set(sourceConfig.id, changeStream);
  }
  
  private async processChange(change: ChangeEvent, target: TargetConfig): Promise<void> {
    switch (change.operationType) {
      case 'insert':
        await this.handleInsert(change.fullDocument, target);
        break;
      case 'update':
        await this.handleUpdate(change.documentKey, change.updateDescription, target);
        break;
      case 'delete':
        await this.handleDelete(change.documentKey, target);
        break;
    }
  }
}
```

**å­¦ç¿’ç›®æ¨™**: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ‡ãƒ¼ã‚¿åŒæœŸã®å®Ÿè£…
**å®Ÿè£…ä¾¡å€¤**: ãƒ‡ãƒ¼ã‚¿ã®å³æ™‚æ€§ç¢ºä¿

**Code-15-1-3-C: å¤§å®¹é‡ãƒ‡ãƒ¼ã‚¿åŠ¹ç‡å–å¾—** (26è¡Œ)
```typescript
// ç›®çš„: å¤§å®¹é‡ãƒ‡ãƒ¼ã‚¿ã®åŠ¹ç‡çš„å–å¾—ã¨ãƒ¡ãƒ¢ãƒªæœ€é©åŒ–
class EfficientBulkDataRetriever {
  async retrieveLargeDataset(query: LargeDataQuery): Promise<DataStream> {
    const batchSize = this.calculateOptimalBatchSize(query);
    const totalRecords = await this.estimateRecordCount(query);
    
    return new DataStream(async function* () {
      let offset = 0;
      
      while (offset < totalRecords) {
        const batch = await this.fetchBatch(query, offset, batchSize);
        
        for (const record of batch) {
          yield this.transformRecord(record);
        }
        
        offset += batchSize;
        await this.throttleIfNeeded();
      }
    }.bind(this));
  }
  
  private calculateOptimalBatchSize(query: LargeDataQuery): number {
    const availableMemory = process.memoryUsage().heapUsed;
    const recordSize = this.estimateRecordSize(query);
    return Math.min(1000, Math.floor(availableMemory * 0.1 / recordSize));
  }
}
```

**å­¦ç¿’ç›®æ¨™**: å¤§å®¹é‡ãƒ‡ãƒ¼ã‚¿ã®åŠ¹ç‡çš„å‡¦ç†
**å®Ÿè£…ä¾¡å€¤**: ãƒ¡ãƒ¢ãƒªåŠ¹ç‡ã¨ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã®æœ€é©åŒ–

#### **15.1.4 ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ã¨ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ãƒ‡ãƒ¼ã‚¿** (3å€‹)

**Code-15-1-4-A: ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†è‡ªå‹•åŒ–** (24è¡Œ)
```typescript
// ç›®çš„: å¤šæ§˜ãªãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã®çµ±ä¸€çš„å‡¦ç†è‡ªå‹•åŒ–
class UniversalFileProcessor {
  async processFile(filePath: string, config: ProcessingConfig): Promise<ProcessedData> {
    const fileType = this.detectFileType(filePath);
    const processor = this.getProcessor(fileType);
    
    const stream = fs.createReadStream(filePath);
    const transformStream = this.createTransformStream(config);
    const validationStream = this.createValidationStream(config.validationRules);
    
    return new Promise((resolve, reject) => {
      const results: ProcessedData[] = [];
      
      stream
        .pipe(processor)
        .pipe(transformStream)
        .pipe(validationStream)
        .on('data', (chunk) => results.push(chunk))
        .on('end', () => resolve(this.aggregateResults(results)))
        .on('error', reject);
    });
  }
  
  private getProcessor(fileType: FileType): Transform {
    const processors = {
      'csv': new CSVProcessor(),
      'json': new JSONProcessor(),
      'xml': new XMLProcessor(),
      'parquet': new ParquetProcessor()
    };
    return processors[fileType] || new GenericProcessor();
  }
}
```

**å­¦ç¿’ç›®æ¨™**: å¤šæ§˜ãªãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã®çµ±ä¸€å‡¦ç†
**å®Ÿè£…ä¾¡å€¤**: ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ã®è‡ªå‹•åŒ–ã¨æ¨™æº–åŒ–

**Code-15-1-4-B: ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ãƒ‡ãƒ¼ã‚¿å‡¦ç†** (27è¡Œ)
```typescript
// ç›®çš„: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ãƒ‡ãƒ¼ã‚¿ã®åŠ¹ç‡çš„å‡¦ç†
class StreamingDataProcessor {
  private kafkaConsumer: KafkaConsumer;
  private processingPipeline: ProcessingPipeline;
  
  async startStreaming(config: StreamingConfig): Promise<void> {
    this.kafkaConsumer = new KafkaConsumer(config.kafka);
    this.processingPipeline = new ProcessingPipeline(config.processing);
    
    await this.kafkaConsumer.subscribe(config.topics);
    
    this.kafkaConsumer.on('message', async (message: KafkaMessage) => {
      try {
        const processedData = await this.processingPipeline.process(message.value);
        await this.forwardToDownstream(processedData);
        await this.kafkaConsumer.commitOffset(message);
      } catch (error) {
        await this.handleProcessingError(message, error);
      }
    });
    
    // ãƒãƒƒã‚¯ãƒ—ãƒ¬ãƒƒã‚·ãƒ£ãƒ¼åˆ¶å¾¡
    this.kafkaConsumer.on('rebalance', () => {
      this.adjustProcessingRate();
    });
  }
  
  private async adjustProcessingRate(): Promise<void> {
    const currentLoad = await this.measureProcessingLoad();
    if (currentLoad > 0.8) {
      this.kafkaConsumer.pause();
      setTimeout(() => this.kafkaConsumer.resume(), 1000);
    }
  }
}
```

**å­¦ç¿’ç›®æ¨™**: ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ãƒ‡ãƒ¼ã‚¿ã®å®Ÿæ™‚é–“å‡¦ç†
**å®Ÿè£…ä¾¡å€¤**: é«˜ã‚¹ãƒ«ãƒ¼ãƒ—ãƒƒãƒˆãƒ»ä½ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·å‡¦ç†

**Code-15-1-4-C: ãƒãƒƒãƒãƒ»ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰å‡¦ç†** (30è¡Œ)
```typescript
// ç›®çš„: ãƒãƒƒãƒå‡¦ç†ã¨ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°å‡¦ç†ã®åŠ¹ç‡çš„çµ±åˆ
class HybridDataProcessor {
  private batchProcessor: BatchProcessor;
  private streamProcessor: StreamProcessor;
  private dataRouter: DataRouter;
  
  async processData(dataSource: DataSource): Promise<ProcessingResult> {
    const routingDecision = await this.dataRouter.determineProcessingMode(dataSource);
    
    switch (routingDecision.mode) {
      case 'batch':
        return await this.processBatch(dataSource, routingDecision.config);
      
      case 'stream':
        return await this.processStream(dataSource, routingDecision.config);
      
      case 'hybrid':
        return await this.processHybrid(dataSource, routingDecision.config);
    }
  }
  
  private async processHybrid(dataSource: DataSource, config: HybridConfig): Promise<ProcessingResult> {
    // å±¥æ­´ãƒ‡ãƒ¼ã‚¿ã‚’ãƒãƒƒãƒå‡¦ç†
    const historicalResult = await this.batchProcessor.processHistorical(
      dataSource, config.batchConfig
    );
    
    // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°å‡¦ç†
    const streamingResult = await this.streamProcessor.processRealtime(
      dataSource, config.streamConfig
    );
    
    // çµæœã‚’çµ±åˆ
    return this.mergeResults(historicalResult, streamingResult);
  }
}
```

**å­¦ç¿’ç›®æ¨™**: ãƒãƒƒãƒãƒ»ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ã®çµ±åˆå‡¦ç†
**å®Ÿè£…ä¾¡å€¤**: å‡¦ç†æ–¹å¼ã®æœ€é©åŒ–ã¨æŸ”è»Ÿæ€§ç¢ºä¿

### **15.2 ãƒ‡ãƒ¼ã‚¿å‰å‡¦ç†ã¨æ§‹é€ åŒ–** (12å€‹)

#### **15.2.1 ãƒ‡ãƒ¼ã‚¿å“è³ªèª²é¡Œã®æˆ¦ç•¥çš„å½±éŸ¿** (3å€‹)

**Code-15-2-1-A: ãƒ‡ãƒ¼ã‚¿å“è³ªè©•ä¾¡æŒ‡æ¨™è¨ˆç®—** (20è¡Œ)
```typescript
// ç›®çš„: åŒ…æ‹¬çš„ãƒ‡ãƒ¼ã‚¿å“è³ªæŒ‡æ¨™ã®è‡ªå‹•è¨ˆç®—
class DataQualityMetricsCalculator {
  calculateQualityScore(dataset: Dataset): QualityScore {
    const completeness = this.calculateCompleteness(dataset);
    const accuracy = this.calculateAccuracy(dataset);
    const consistency = this.calculateConsistency(dataset);
    const timeliness = this.calculateTimeliness(dataset);
    const validity = this.calculateValidity(dataset);
    
    return {
      overall: (completeness + accuracy + consistency + timeliness + validity) / 5,
      dimensions: { completeness, accuracy, consistency, timeliness, validity },
      recommendations: this.generateRecommendations(dataset)
    };
  }
  
  private calculateCompleteness(dataset: Dataset): number {
    const totalFields = dataset.schema.fields.length * dataset.records.length;
    const nonNullFields = dataset.records.reduce((count, record) => 
      count + Object.values(record).filter(value => value !== null).length, 0
    );
    return nonNullFields / totalFields;
  }
}
```

**å­¦ç¿’ç›®æ¨™**: ãƒ‡ãƒ¼ã‚¿å“è³ªã®å®šé‡çš„è©•ä¾¡æ‰‹æ³•
**å®Ÿè£…ä¾¡å€¤**: å“è³ªå•é¡Œã®æ—©æœŸç™ºè¦‹ã¨å¯¾ç­–

**Code-15-2-1-B: å“è³ªå•é¡Œå½±éŸ¿åº¦åˆ†æ** (22è¡Œ)
```typescript
// ç›®çš„: ãƒ‡ãƒ¼ã‚¿å“è³ªå•é¡ŒãŒãƒ“ã‚¸ãƒã‚¹ã«ä¸ãˆã‚‹å½±éŸ¿ã®å®šé‡åŒ–
class QualityImpactAnalyzer {
  analyzeBusinessImpact(qualityIssues: QualityIssue[], businessContext: BusinessContext): ImpactAnalysis {
    const impactScores = qualityIssues.map(issue => {
      const severity = this.calculateSeverity(issue);
      const businessCriticality = this.assessBusinessCriticality(issue, businessContext);
      const propagationRisk = this.calculatePropagationRisk(issue);
      
      return {
        issue,
        impactScore: severity * businessCriticality * propagationRisk,
        estimatedCost: this.estimateFinancialImpact(issue, businessContext),
        urgency: this.calculateUrgency(issue)
      };
    });
    
    return {
      totalImpactScore: impactScores.reduce((sum, score) => sum + score.impactScore, 0),
      prioritizedIssues: impactScores.sort((a, b) => b.impactScore - a.impactScore),
      recommendedActions: this.generateActionPlan(impactScores)
    };
  }
}
```

**å­¦ç¿’ç›®æ¨™**: å“è³ªå•é¡Œã®ãƒ“ã‚¸ãƒã‚¹å½±éŸ¿è©•ä¾¡
**å®Ÿè£…ä¾¡å€¤**: å“è³ªæ”¹å–„æŠ•è³‡ã®å„ªå…ˆé †ä½æ±ºå®š

**Code-15-2-1-C: å“è³ªæ”¹å–„ROIè¨ˆç®—** (18è¡Œ)
```typescript
// ç›®çš„: ãƒ‡ãƒ¼ã‚¿å“è³ªæ”¹å–„æŠ•è³‡ã®æŠ•è³‡å¯¾åŠ¹æœè¨ˆç®—
class QualityImprovementROICalculator {
  calculateROI(improvementPlan: ImprovementPlan, timeframe: number): ROIAnalysis {
    const implementationCost = this.calculateImplementationCost(improvementPlan);
    const operationalCost = this.calculateOperationalCost(improvementPlan, timeframe);
    const totalCost = implementationCost + operationalCost;
    
    const qualityBenefits = this.calculateQualityBenefits(improvementPlan, timeframe);
    const efficiencyGains = this.calculateEfficiencyGains(improvementPlan, timeframe);
    const riskReduction = this.calculateRiskReduction(improvementPlan, timeframe);
    const totalBenefits = qualityBenefits + efficiencyGains + riskReduction;
    
    return {
      roi: (totalBenefits - totalCost) / totalCost,
      paybackPeriod: this.calculatePaybackPeriod(totalCost, totalBenefits, timeframe),
      netPresentValue: this.calculateNPV(totalCost, totalBenefits, timeframe)
    };
  }
}
```

**å­¦ç¿’ç›®æ¨™**: å“è³ªæ”¹å–„æŠ•è³‡ã®çµŒæ¸ˆæ€§è©•ä¾¡
**å®Ÿè£…ä¾¡å€¤**: ãƒ‡ãƒ¼ã‚¿å“è³ªæŠ•è³‡ã®æ­£å½“åŒ–

#### **15.2.2 ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ã¨æ­£è¦åŒ–** (3å€‹)

**Code-15-2-2-A: æ¬ æå€¤å‡¦ç†è‡ªå‹•åŒ–** (25è¡Œ)
```typescript
// ç›®çš„: æ–‡è„ˆã‚’è€ƒæ…®ã—ãŸé©å¿œçš„æ¬ æå€¤å‡¦ç†
class AdaptiveMissingValueHandler {
  async handleMissingValues(dataset: Dataset, strategy: MissingValueStrategy): Promise<Dataset> {
    const missingValueAnalysis = this.analyzeMissingPatterns(dataset);
    const processedDataset = dataset.clone();
    
    for (const column of dataset.columns) {
      const missingInfo = missingValueAnalysis[column.name];
      const optimalStrategy = this.selectOptimalStrategy(missingInfo, strategy);
      
      switch (optimalStrategy.method) {
        case 'interpolation':
          await this.interpolateValues(processedDataset, column, optimalStrategy.config);
          break;
        case 'prediction':
          await this.predictMissingValues(processedDataset, column, optimalStrategy.config);
          break;
        case 'deletion':
          await this.deleteIncompleteRecords(processedDataset, column, optimalStrategy.config);
          break;
        case 'imputation':
          await this.imputeValues(processedDataset, column, optimalStrategy.config);
          break;
      }
    }
    
    return this.validateProcessedDataset(processedDataset);
  }
}
```

**å­¦ç¿’ç›®æ¨™**: é©å¿œçš„æ¬ æå€¤å‡¦ç†ã®å®Ÿè£…
**å®Ÿè£…ä¾¡å€¤**: ãƒ‡ãƒ¼ã‚¿å®Œå…¨æ€§ã®å‘ä¸Š

**Code-15-2-2-B: ç•°å¸¸å€¤æ¤œå‡ºãƒ»ä¿®æ­£ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ** (28è¡Œ)
```typescript
// ç›®çš„: å¤šå±¤çš„ç•°å¸¸å€¤æ¤œå‡ºã¨è‡ªå‹•ä¿®æ­£
class MultiLayerOutlierDetector {
  async detectAndCorrectOutliers(dataset: Dataset, config: OutlierConfig): Promise<OutlierResult> {
    const detectionResults = await Promise.all([
      this.statisticalDetection(dataset, config.statistical),
      this.machinelearningDetection(dataset, config.ml),
      this.domainRuleDetection(dataset, config.domainRules)
    ]);
    
    const consolidatedOutliers = this.consolidateDetections(detectionResults);
    const correctionPlan = this.createCorrectionPlan(consolidatedOutliers);
    
    const correctedDataset = dataset.clone();
    
    for (const outlier of consolidatedOutliers) {
      const correction = correctionPlan.getCorrection(outlier);
      
      switch (correction.action) {
        case 'remove':
          correctedDataset.removeRecord(outlier.recordId);
          break;
        case 'correct':
          correctedDataset.updateValue(outlier.recordId, outlier.field, correction.newValue);
          break;
        case 'flag':
          correctedDataset.flagRecord(outlier.recordId, 'potential_outlier');
          break;
      }
    }
    
    return { correctedDataset, outlierReport: this.generateReport(consolidatedOutliers) };
  }
}
```

**å­¦ç¿’ç›®æ¨™**: é«˜åº¦ãªç•°å¸¸å€¤æ¤œå‡ºã¨ä¿®æ­£
**å®Ÿè£…ä¾¡å€¤**: ãƒ‡ãƒ¼ã‚¿ç²¾åº¦ã®å‘ä¸Š

**Code-15-2-2-C: ãƒ‡ãƒ¼ã‚¿å½¢å¼çµ±ä¸€ãƒ»æ­£è¦åŒ–** (24è¡Œ)
```typescript
// ç›®çš„: ç•°ç¨®ãƒ‡ãƒ¼ã‚¿å½¢å¼ã®çµ±ä¸€çš„æ­£è¦åŒ–
class DataNormalizationEngine {
  async normalizeDataset(dataset: Dataset, schema: NormalizationSchema): Promise<NormalizedDataset> {
    const normalizedDataset = new NormalizedDataset(schema);
    
    for (const record of dataset.records) {
      const normalizedRecord = {};
      
      for (const [fieldName, fieldConfig] of Object.entries(schema.fields)) {
        const rawValue = record[fieldConfig.sourceField];
        const normalizedValue = await this.normalizeField(rawValue, fieldConfig);
        normalizedRecord[fieldName] = normalizedValue;
      }
      
      // ãƒ‡ãƒ¼ã‚¿å‹å¤‰æ›
      const typedRecord = this.applyTypeConversion(normalizedRecord, schema.types);
      
      // å˜ä½å¤‰æ›
      const unitConvertedRecord = this.applyUnitConversion(typedRecord, schema.units);
      
      // æ¤œè¨¼
      if (this.validateRecord(unitConvertedRecord, schema.validation)) {
        normalizedDataset.addRecord(unitConvertedRecord);
      }
    }
    
    return normalizedDataset;
  }
}
```

**å­¦ç¿’ç›®æ¨™**: ãƒ‡ãƒ¼ã‚¿å½¢å¼ã®çµ±ä¸€ã¨æ­£è¦åŒ–
**å®Ÿè£…ä¾¡å€¤**: ãƒ‡ãƒ¼ã‚¿ä¸€è²«æ€§ã®ç¢ºä¿

#### **15.2.3 ãƒ‡ãƒ¼ã‚¿å¤‰æ›ã¨ã‚¨ãƒ³ãƒªãƒƒãƒãƒ¡ãƒ³ãƒˆ** (3å€‹)

**Code-15-2-3-A: æ§‹é€ åŒ–ãƒ»éæ§‹é€ åŒ–ãƒ‡ãƒ¼ã‚¿çµ±åˆ** (26è¡Œ)
```typescript
// ç›®çš„: æ§‹é€ åŒ–ãƒ»éæ§‹é€ åŒ–ãƒ‡ãƒ¼ã‚¿ã®åŠ¹ç‡çš„çµ±åˆ
class HybridDataIntegrator {
  async integrateHybridData(sources: HybridDataSources): Promise<IntegratedDataset> {
    const structuredData = await this.processStructuredSources(sources.structured);
    const unstructuredData = await this.processUnstructuredSources(sources.unstructured);
    
    // éæ§‹é€ åŒ–ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰æ§‹é€ åŒ–æƒ…å ±ã‚’æŠ½å‡º
    const extractedStructure = await this.extractStructureFromUnstructured(unstructuredData);
    
    // å…±é€šã‚­ãƒ¼ã«ã‚ˆã‚‹é–¢é€£ä»˜ã‘
    const linkedData = await this.linkDataByCommonKeys(structuredData, extractedStructure);
    
    // ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯çµ±åˆ
    const semanticallyIntegrated = await this.performSemanticIntegration(linkedData);
    
    return new IntegratedDataset({
      structured: semanticallyIntegrated.structured,
      enriched: semanticallyIntegrated.enriched,
      metadata: this.generateIntegrationMetadata(sources),
      qualityMetrics: this.calculateIntegrationQuality(semanticallyIntegrated)
    });
  }
  
  private async extractStructureFromUnstructured(data: UnstructuredData): Promise<StructuredData> {
    // NLPã€ç”»åƒèªè­˜ã€éŸ³å£°èªè­˜ç­‰ã‚’æ´»ç”¨ã—ãŸæ§‹é€ åŒ–
    return await this.nlpProcessor.extractEntities(data);
  }
}
```

**å­¦ç¿’ç›®æ¨™**: ç•°ç¨®ãƒ‡ãƒ¼ã‚¿ã®çµ±åˆå‡¦ç†
**å®Ÿè£…ä¾¡å€¤**: ãƒ‡ãƒ¼ã‚¿æ´»ç”¨ç¯„å›²ã®æ‹¡å¤§

**Code-15-2-3-B: å¤–éƒ¨ãƒ‡ãƒ¼ã‚¿ã‚¨ãƒ³ãƒªãƒƒãƒãƒ¡ãƒ³ãƒˆ** (29è¡Œ)
```typescript
// ç›®çš„: å¤–éƒ¨ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹ã«ã‚ˆã‚‹åŒ…æ‹¬çš„ãƒ‡ãƒ¼ã‚¿ã‚¨ãƒ³ãƒªãƒƒãƒãƒ¡ãƒ³ãƒˆ
class ExternalDataEnricher {
  private enrichmentSources: Map<string, EnrichmentSource> = new Map();
  
  async enrichDataset(dataset: Dataset, enrichmentConfig: EnrichmentConfig): Promise<EnrichedDataset> {
    const enrichmentPlan = this.createEnrichmentPlan(dataset, enrichmentConfig);
    const enrichedDataset = dataset.clone();
    
    for (const record of enrichedDataset.records) {
      const enrichmentTasks = enrichmentPlan.getTasksForRecord(record);
      
      const enrichmentResults = await Promise.all(
        enrichmentTasks.map(task => this.executeEnrichmentTask(record, task))
      );
      
      // ã‚¨ãƒ³ãƒªãƒƒãƒãƒ¡ãƒ³ãƒˆçµæœã‚’ãƒ¬ã‚³ãƒ¼ãƒ‰ã«çµ±åˆ
      for (const result of enrichmentResults) {
        if (result.success) {
          Object.assign(record, result.enrichedData);
          record._enrichmentMetadata = {
            ...record._enrichmentMetadata,
            [result.source]: result.metadata
          };
        }
      }
    }
    
    return new EnrichedDataset(enrichedDataset, {
      enrichmentSources: Array.from(this.enrichmentSources.keys()),
      enrichmentQuality: this.assessEnrichmentQuality(enrichedDataset)
    });
  }
  
  private async executeEnrichmentTask(record: DataRecord, task: EnrichmentTask): Promise<EnrichmentResult> {
    const source = this.enrichmentSources.get(task.sourceName);
    return await source.enrich(record, task.config);
  }
}
```

**å­¦ç¿’ç›®æ¨™**: å¤–éƒ¨ãƒ‡ãƒ¼ã‚¿ã«ã‚ˆã‚‹ã‚¨ãƒ³ãƒªãƒƒãƒãƒ¡ãƒ³ãƒˆ
**å®Ÿè£…ä¾¡å€¤**: ãƒ‡ãƒ¼ã‚¿ä¾¡å€¤ã®å‘ä¸Š

**Code-15-2-3-C: æ´¾ç”Ÿé …ç›®ãƒ»è¨ˆç®—é …ç›®ç”Ÿæˆ** (23è¡Œ)
```typescript
// ç›®çš„: ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã«åŸºã¥ãæ´¾ç”Ÿé …ç›®ã®è‡ªå‹•ç”Ÿæˆ
class DerivedFieldGenerator {
  async generateDerivedFields(dataset: Dataset, derivationRules: DerivationRule[]): Promise<Dataset> {
    const enhancedDataset = dataset.clone();
    
    // ä¾å­˜é–¢ä¿‚ã«åŸºã¥ãå®Ÿè¡Œé †åºã®æ±ºå®š
    const executionOrder = this.resolveDependencies(derivationRules);
    
    for (const rule of executionOrder) {
      for (const record of enhancedDataset.records) {
        try {
          const derivedValue = await this.calculateDerivedValue(record, rule);
          record[rule.targetField] = derivedValue;
          
          // è¨ˆç®—ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã®è¨˜éŒ²
          record._derivationMetadata = {
            ...record._derivationMetadata,
            [rule.targetField]: {
              rule: rule.name,
              calculatedAt: new Date(),
              sourceFields: rule.sourceFields
            }
          };
        } catch (error) {
          this.handleDerivationError(record, rule, error);
        }
      }
    }
    
    return enhancedDataset;
  }
}
```

**å­¦ç¿’ç›®æ¨™**: ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ãƒ™ãƒ¼ã‚¹ã®é …ç›®ç”Ÿæˆ
**å®Ÿè£…ä¾¡å€¤**: ãƒ‡ãƒ¼ã‚¿åˆ†æä¾¡å€¤ã®å‘ä¸Š

#### **15.2.4 æ¤œè¨¼ã¨ãƒ“ã‚¸ãƒã‚¹ãƒ«ãƒ¼ãƒ«é©ç”¨** (3å€‹)

**Code-15-2-4-A: ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯** (22è¡Œ)
```typescript
// ç›®çš„: åŒ…æ‹¬çš„ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ã®è‡ªå‹•æ¤œè¨¼
class DataIntegrityValidator {
  async validateIntegrity(dataset: Dataset, integrityRules: IntegrityRule[]): Promise<ValidationResult> {
    const validationResults: ValidationIssue[] = [];
    
    for (const rule of integrityRules) {
      const ruleResults = await this.executeIntegrityRule(dataset, rule);
      validationResults.push(...ruleResults);
    }
    
    // æ•´åˆæ€§é•åã®åˆ†æ
    const violationAnalysis = this.analyzeViolations(validationResults);
    
    // è‡ªå‹•ä¿®æ­£å¯èƒ½ãªå•é¡Œã®ç‰¹å®š
    const autoFixableIssues = validationResults.filter(issue => issue.autoFixable);
    
    // ä¿®æ­£ææ¡ˆã®ç”Ÿæˆ
    const correctionProposals = this.generateCorrectionProposals(validationResults);
    
    return {
      isValid: validationResults.length === 0,
      violations: validationResults,
      analysis: violationAnalysis,
      autoFixableCount: autoFixableIssues.length,
      correctionProposals
    };
  }
}
```

**å­¦ç¿’ç›®æ¨™**: ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ã®è‡ªå‹•æ¤œè¨¼
**å®Ÿè£…ä¾¡å€¤**: ãƒ‡ãƒ¼ã‚¿ä¿¡é ¼æ€§ã®ç¢ºä¿

**Code-15-2-4-B: ãƒ“ã‚¸ãƒã‚¹ãƒ«ãƒ¼ãƒ«é©ç”¨ã‚¨ãƒ³ã‚¸ãƒ³** (27è¡Œ)
```typescript
// ç›®çš„: å‹•çš„ãƒ“ã‚¸ãƒã‚¹ãƒ«ãƒ¼ãƒ«ã®åŠ¹ç‡çš„é©ç”¨
class BusinessRuleEngine {
  private ruleRepository: RuleRepository;
  private ruleExecutor: RuleExecutor;
  
  async applyBusinessRules(dataset: Dataset, context: BusinessContext): Promise<RuleApplicationResult> {
    // ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«åŸºã¥ãé©ç”¨ãƒ«ãƒ¼ãƒ«ã®é¸æŠ
    const applicableRules = await this.ruleRepository.getApplicableRules(context);
    
    const applicationResults: RuleResult[] = [];
    const modifiedDataset = dataset.clone();
    
    for (const record of modifiedDataset.records) {
      for (const rule of applicableRules) {
        const ruleResult = await this.ruleExecutor.execute(rule, record, context);
        
        if (ruleResult.action) {
          switch (ruleResult.action.type) {
            case 'modify':
              this.applyModification(record, ruleResult.action);
              break;
            case 'flag':
              this.flagRecord(record, ruleResult.action);
              break;
            case 'reject':
              this.rejectRecord(record, ruleResult.action);
              break;
          }
        }
        
        applicationResults.push(ruleResult);
      }
    }
    
    return { modifiedDataset, ruleResults: applicationResults };
  }
}
```

**å­¦ç¿’ç›®æ¨™**: ãƒ“ã‚¸ãƒã‚¹ãƒ«ãƒ¼ãƒ«ã®å‹•çš„é©ç”¨
**å®Ÿè£…ä¾¡å€¤**: ãƒ“ã‚¸ãƒã‚¹è¦ä»¶ã®è‡ªå‹•åŒ–

**Code-15-2-4-C: æ¤œè¨¼çµæœãƒ¬ãƒãƒ¼ãƒ†ã‚£ãƒ³ã‚°** (20è¡Œ)
```typescript
// ç›®çš„: åŒ…æ‹¬çš„æ¤œè¨¼çµæœã®æ§‹é€ åŒ–ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
class ValidationReportGenerator {
  generateComprehensiveReport(validationResults: ValidationResult[]): ValidationReport {
    const summary = this.generateSummary(validationResults);
    const detailedAnalysis = this.generateDetailedAnalysis(validationResults);
    const recommendations = this.generateRecommendations(validationResults);
    
    return {
      executionTimestamp: new Date(),
      summary: {
        totalRecordsValidated: summary.totalRecords,
        validRecords: summary.validRecords,
        invalidRecords: summary.invalidRecords,
        validationRate: summary.validRecords / summary.totalRecords
      },
      issueBreakdown: this.categorizeIssues(validationResults),
      severityDistribution: this.analyzeSeverity(validationResults),
      recommendations: recommendations,
      actionPlan: this.generateActionPlan(validationResults),
      exportFormats: this.generateExports(validationResults)
    };
  }
}
```

**å­¦ç¿’ç›®æ¨™**: æ¤œè¨¼çµæœã®åŠ¹æœçš„ãƒ¬ãƒãƒ¼ãƒ†ã‚£ãƒ³ã‚°
**å®Ÿè£…ä¾¡å€¤**: å“è³ªç®¡ç†ã®å¯è¦–åŒ–

### **15.3 ãƒ‡ãƒ¼ã‚¿å“è³ªç®¡ç†** (12å€‹)

[15.3ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®12å€‹ã®æ¦‚å¿µå®Ÿè¨¼ã‚³ãƒ¼ãƒ‰ã‚‚åŒæ§˜ã®è©³ç´°è¨­è¨ˆ...]

### **15.4 ã‚¹ã‚±ãƒ¼ãƒ©ãƒ–ãƒ«ãƒ‡ãƒ¼ã‚¿å‡¦ç†** (12å€‹)

[15.4ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®12å€‹ã®æ¦‚å¿µå®Ÿè¨¼ã‚³ãƒ¼ãƒ‰ã‚‚åŒæ§˜ã®è©³ç´°è¨­è¨ˆ...]

## ğŸ“Š æ¦‚å¿µå®Ÿè¨¼ã‚³ãƒ¼ãƒ‰é…ç½®ãƒ»é‡è©•ä¾¡çµæœ

### **é‡çš„è©•ä¾¡**

**ç·æ¦‚å¿µå®Ÿè¨¼ã‚³ãƒ¼ãƒ‰æ•°**: 48å€‹
**å¹³å‡ã‚³ãƒ¼ãƒ‰è¡Œæ•°**: 25è¡Œ
**ç·ã‚³ãƒ¼ãƒ‰è¡Œæ•°**: ç´„1,200è¡Œ
**ã‚»ã‚¯ã‚·ãƒ§ãƒ³åˆ¥åˆ†å¸ƒ**: å„ã‚»ã‚¯ã‚·ãƒ§ãƒ³12å€‹ï¼ˆå‡ç­‰é…ç½®ï¼‰

### **è³ªçš„è©•ä¾¡**

**å­¦ç¿’åŠ¹æœ**: æ®µéšçš„ç†è§£ä¿ƒé€²ã«æœ€é©åŒ–
**å®Ÿè£…ä¾¡å€¤**: å®Ÿéš›ã®æ¥­å‹™ã§æ´»ç”¨å¯èƒ½
**æŠ€è¡“çš„å®Œå…¨æ€§**: å‹•ä½œå¯èƒ½ãªå®Ÿè£…ä¾‹
**èª­è€…å±¤åˆ¥å¯¾å¿œ**: å…¨èª­è€…å±¤ã®å­¦ç¿’ãƒ‹ãƒ¼ã‚ºã«å¯¾å¿œ

### **é…ç½®æˆ¦ç•¥ã®å¦¥å½“æ€§**

**è«–ç†çš„é…ç½®**: å†…å®¹ã®æµã‚Œã«æ²¿ã£ãŸé©åˆ‡ãªé…ç½®
**å­¦ç¿’æ”¯æ´**: ç†è«–â†’å®Ÿè£…â†’å¿œç”¨ã®æ®µéšçš„å±•é–‹
**å®Ÿè·µçš„ä¾¡å€¤**: å®Ÿéš›ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§æ´»ç”¨å¯èƒ½ãªå®Ÿè£…ä¾‹

ã“ã®è©³ç´°è¨­è¨ˆã«ã‚ˆã‚Šã€ç¬¬15ç« ã®æ¦‚å¿µå®Ÿè¨¼ã‚³ãƒ¼ãƒ‰ã¯å­¦ç¿’åŠ¹æœã‚’æœ€å¤§åŒ–ã—ã€å®Ÿè·µçš„ä¾¡å€¤ã‚’æä¾›ã™ã‚‹æœ€é©ãªé…ç½®ã¨é‡ã‚’å®Ÿç¾ã—ã¾ã™ã€‚

