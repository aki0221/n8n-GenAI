# 第7章: インターフェース設計

**作成支援**: Manus AI

## API設計の詳細化

トリプルパースペクティブ型戦略AIレーダーの効果的な運用には、多様なクライアントとシステムが統合的にアクセスできる包括的なインターフェース設計が不可欠です。本セクションでは、RESTful API、GraphQL、リアルタイム通信を統合した現代的なAPI設計を詳細に解説します。

### RESTful API設計原則

我々のRESTful API設計は、業界標準のベストプラクティスに基づき、一貫性、拡張性、保守性を重視した設計を採用します。

#### 基本設計原則

**リソース中心設計**では、システムの主要エンティティ（戦略的洞察、視点分析、コンセンサス結果）をリソースとして表現し、HTTPメソッドによる操作を定義します。

**統一インターフェース**では、すべてのAPIエンドポイントで一貫した命名規則、レスポンス形式、エラーハンドリングを適用します。

**ステートレス設計**では、各リクエストが完全な情報を含み、サーバー側でセッション状態を保持しない設計を採用します。

```python
# api/v1/strategic_insights.py
from fastapi import FastAPI, HTTPException, Depends, Query, Path
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel, Field, validator
from typing import List, Optional, Dict, Any
from datetime import datetime, timedelta
from enum import Enum
import uuid
import logging

# セキュリティ設定
security = HTTPBearer()
logger = logging.getLogger(__name__)

# 基本データモデル
class PerspectiveType(str, Enum):
    TECHNOLOGY = "technology"
    MARKET = "market"
    BUSINESS = "business"

class InsightStatus(str, Enum):
    DRAFT = "draft"
    ANALYZING = "analyzing"
    CONSENSUS_PENDING = "consensus_pending"
    VALIDATED = "validated"
    IMPLEMENTED = "implemented"
    ARCHIVED = "archived"

class ConfidenceLevel(str, Enum):
    VERY_HIGH = "very_high"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    VERY_LOW = "very_low"

class UrgencyLevel(str, Enum):
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    PLANNING = "planning"

# リクエスト/レスポンスモデル
class CreateInsightRequest(BaseModel):
    title: str = Field(..., min_length=1, max_length=200, description="洞察のタイトル")
    description: str = Field(..., min_length=1, max_length=2000, description="洞察の詳細説明")
    category: str = Field(..., min_length=1, max_length=100, description="カテゴリ")
    tags: List[str] = Field(default_factory=list, description="タグリスト")
    priority: int = Field(default=3, ge=1, le=5, description="優先度（1-5）")
    
    @validator('tags')
    def validate_tags(cls, v):
        if len(v) > 10:
            raise ValueError('タグは最大10個まで')
        return v

class UpdateInsightRequest(BaseModel):
    title: Optional[str] = Field(None, min_length=1, max_length=200)
    description: Optional[str] = Field(None, min_length=1, max_length=2000)
    category: Optional[str] = Field(None, min_length=1, max_length=100)
    tags: Optional[List[str]] = None
    priority: Optional[int] = Field(None, ge=1, le=5)
    status: Optional[InsightStatus] = None

class MetricResponse(BaseModel):
    name: str
    value: Any
    unit: Optional[str] = None
    confidence: float
    timestamp: datetime
    source: Optional[str] = None

class PerspectiveAnalysisResponse(BaseModel):
    perspective_type: PerspectiveType
    analysis_id: str
    importance_score: float
    confidence_score: float
    urgency_score: float
    impact_score: float
    metrics: List[MetricResponse]
    key_findings: List[str]
    recommendations: List[str]
    risks: List[str]
    opportunities: List[str]
    analysis_timestamp: datetime
    quality_score: float

class ConsensusResultResponse(BaseModel):
    consensus_id: str
    consensus_score: float
    convergence_achieved: bool
    equilibrium_point: Optional[Dict[str, float]]
    perspective_alignment: Dict[str, float]
    conflict_areas: List[str]
    agreement_areas: List[str]
    integrated_recommendations: List[str]
    priority_actions: List[str]
    consensus_timestamp: datetime
    consensus_quality: float

class StrategicInsightResponse(BaseModel):
    insight_id: str
    title: str
    description: str
    category: str
    tags: List[str]
    status: InsightStatus
    confidence_level: ConfidenceLevel
    urgency_level: UrgencyLevel
    
    # 視点別分析
    technology_analysis: Optional[PerspectiveAnalysisResponse]
    market_analysis: Optional[PerspectiveAnalysisResponse]
    business_analysis: Optional[PerspectiveAnalysisResponse]
    
    # コンセンサス結果
    consensus_result: Optional[ConsensusResultResponse]
    
    # 統合評価
    overall_importance: float
    overall_confidence: float
    overall_urgency: float
    overall_impact: float
    strategic_value: float
    
    # メタデータ
    created_timestamp: datetime
    updated_timestamp: datetime
    validation_timestamp: Optional[datetime]
    completion_percentage: float
    
    class Config:
        schema_extra = {
            "example": {
                "insight_id": "insight_123",
                "title": "AI技術導入による市場競争力強化",
                "description": "機械学習技術の導入により、製品開発効率と市場対応速度の向上を図る戦略的施策",
                "category": "technology_adoption",
                "tags": ["AI", "machine_learning", "competitive_advantage"],
                "status": "validated",
                "confidence_level": "high",
                "urgency_level": "medium",
                "overall_importance": 0.85,
                "overall_confidence": 0.78,
                "overall_urgency": 0.72,
                "overall_impact": 0.88,
                "strategic_value": 2.45,
                "completion_percentage": 100.0
            }
        }

class InsightListResponse(BaseModel):
    insights: List[StrategicInsightResponse]
    total_count: int
    page_info: Dict[str, Any]

class ErrorResponse(BaseModel):
    status: str = "error"
    code: str
    message: str
    details: Optional[Dict[str, Any]] = None
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    request_id: Optional[str] = None

# 認証・認可
async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """JWT トークンからユーザー情報を取得"""
    try:
        # JWT デコードとユーザー検証のロジック
        # 実装では、JWT ライブラリを使用してトークンを検証
        token = credentials.credentials
        # user = await verify_jwt_token(token)
        # return user
        return {"user_id": "user_123", "email": "user@example.com"}  # サンプル
    except Exception as e:
        raise HTTPException(status_code=401, detail="Invalid authentication credentials")

async def check_insight_permission(insight_id: str, user: dict, action: str):
    """洞察に対する権限チェック"""
    # 権限チェックロジック
    # 実装では、データベースから権限情報を取得して検証
    return True  # サンプル

# FastAPI アプリケーション
app = FastAPI(
    title="Strategic AI Radar API",
    description="トリプルパースペクティブ型戦略AIレーダー API",
    version="1.0.0",
    docs_url="/api/v1/docs",
    redoc_url="/api/v1/redoc"
)

# 戦略的洞察管理エンドポイント
@app.post(
    "/api/v1/insights",
    response_model=StrategicInsightResponse,
    status_code=201,
    summary="新規戦略的洞察の作成",
    description="新しい戦略的洞察を作成し、3つの視点での分析を開始します。"
)
async def create_insight(
    request: CreateInsightRequest,
    user: dict = Depends(get_current_user)
):
    """新規戦略的洞察の作成"""
    try:
        # 洞察の作成ロジック
        insight_id = str(uuid.uuid4())
        
        # データベースへの保存
        # insight = await insight_service.create_insight(request, user)
        
        # サンプルレスポンス
        response = StrategicInsightResponse(
            insight_id=insight_id,
            title=request.title,
            description=request.description,
            category=request.category,
            tags=request.tags,
            status=InsightStatus.DRAFT,
            confidence_level=ConfidenceLevel.MEDIUM,
            urgency_level=UrgencyLevel.MEDIUM,
            overall_importance=0.0,
            overall_confidence=0.0,
            overall_urgency=0.0,
            overall_impact=0.0,
            strategic_value=0.0,
            created_timestamp=datetime.utcnow(),
            updated_timestamp=datetime.utcnow(),
            completion_percentage=0.0
        )
        
        logger.info(f"Created new insight: {insight_id} by user: {user['user_id']}")
        return response
        
    except Exception as e:
        logger.error(f"Error creating insight: {str(e)}")
        raise HTTPException(status_code=500, detail="Internal server error")

@app.get(
    "/api/v1/insights",
    response_model=InsightListResponse,
    summary="戦略的洞察一覧の取得",
    description="フィルタリング、ソート、ページネーション機能付きで戦略的洞察の一覧を取得します。"
)
async def list_insights(
    status: Optional[InsightStatus] = Query(None, description="ステータスフィルタ"),
    category: Optional[str] = Query(None, description="カテゴリフィルタ"),
    tags: Optional[str] = Query(None, description="タグフィルタ（カンマ区切り）"),
    min_importance: Optional[float] = Query(None, ge=0.0, le=1.0, description="最小重要度"),
    min_confidence: Optional[float] = Query(None, ge=0.0, le=1.0, description="最小信頼度"),
    sort_by: Optional[str] = Query("updated_timestamp", description="ソート項目"),
    sort_order: Optional[str] = Query("desc", regex="^(asc|desc)$", description="ソート順"),
    page: int = Query(1, ge=1, description="ページ番号"),
    limit: int = Query(20, ge=1, le=100, description="1ページあたりの件数"),
    user: dict = Depends(get_current_user)
):
    """戦略的洞察一覧の取得"""
    try:
        # フィルタリング条件の構築
        filters = {}
        if status:
            filters['status'] = status
        if category:
            filters['category'] = category
        if tags:
            filters['tags'] = tags.split(',')
        if min_importance is not None:
            filters['min_importance'] = min_importance
        if min_confidence is not None:
            filters['min_confidence'] = min_confidence
        
        # データベースクエリ
        # insights, total_count = await insight_service.list_insights(
        #     filters=filters,
        #     sort_by=sort_by,
        #     sort_order=sort_order,
        #     page=page,
        #     limit=limit,
        #     user=user
        # )
        
        # サンプルレスポンス
        insights = []  # 実際の実装では、データベースから取得
        total_count = 0
        
        page_info = {
            "current_page": page,
            "total_pages": (total_count + limit - 1) // limit,
            "total_count": total_count,
            "has_next": page * limit < total_count,
            "has_previous": page > 1
        }
        
        return InsightListResponse(
            insights=insights,
            total_count=total_count,
            page_info=page_info
        )
        
    except Exception as e:
        logger.error(f"Error listing insights: {str(e)}")
        raise HTTPException(status_code=500, detail="Internal server error")

@app.get(
    "/api/v1/insights/{insight_id}",
    response_model=StrategicInsightResponse,
    summary="戦略的洞察詳細の取得",
    description="指定されたIDの戦略的洞察の詳細情報を取得します。"
)
async def get_insight(
    insight_id: str = Path(..., description="洞察ID"),
    user: dict = Depends(get_current_user)
):
    """戦略的洞察詳細の取得"""
    try:
        # 権限チェック
        await check_insight_permission(insight_id, user, "read")
        
        # データベースから取得
        # insight = await insight_service.get_insight(insight_id, user)
        # if not insight:
        #     raise HTTPException(status_code=404, detail="Insight not found")
        
        # サンプルレスポンス（実際の実装では、データベースから取得したデータを返す）
        raise HTTPException(status_code=404, detail="Insight not found")
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting insight {insight_id}: {str(e)}")
        raise HTTPException(status_code=500, detail="Internal server error")

@app.put(
    "/api/v1/insights/{insight_id}",
    response_model=StrategicInsightResponse,
    summary="戦略的洞察の更新",
    description="指定されたIDの戦略的洞察を更新します。"
)
async def update_insight(
    insight_id: str = Path(..., description="洞察ID"),
    request: UpdateInsightRequest = ...,
    user: dict = Depends(get_current_user)
):
    """戦略的洞察の更新"""
    try:
        # 権限チェック
        await check_insight_permission(insight_id, user, "update")
        
        # 更新処理
        # insight = await insight_service.update_insight(insight_id, request, user)
        # if not insight:
        #     raise HTTPException(status_code=404, detail="Insight not found")
        
        # サンプルレスポンス
        raise HTTPException(status_code=404, detail="Insight not found")
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error updating insight {insight_id}: {str(e)}")
        raise HTTPException(status_code=500, detail="Internal server error")

@app.delete(
    "/api/v1/insights/{insight_id}",
    status_code=204,
    summary="戦略的洞察の削除",
    description="指定されたIDの戦略的洞察を削除します。"
)
async def delete_insight(
    insight_id: str = Path(..., description="洞察ID"),
    user: dict = Depends(get_current_user)
):
    """戦略的洞察の削除"""
    try:
        # 権限チェック
        await check_insight_permission(insight_id, user, "delete")
        
        # 削除処理
        # success = await insight_service.delete_insight(insight_id, user)
        # if not success:
        #     raise HTTPException(status_code=404, detail="Insight not found")
        
        logger.info(f"Deleted insight: {insight_id} by user: {user['user_id']}")
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error deleting insight {insight_id}: {str(e)}")
        raise HTTPException(status_code=500, detail="Internal server error")

# 視点分析エンドポイント
@app.post(
    "/api/v1/insights/{insight_id}/analysis/{perspective_type}",
    response_model=PerspectiveAnalysisResponse,
    status_code=201,
    summary="視点分析の開始",
    description="指定された視点での分析を開始します。"
)
async def start_perspective_analysis(
    insight_id: str = Path(..., description="洞察ID"),
    perspective_type: PerspectiveType = Path(..., description="視点タイプ"),
    user: dict = Depends(get_current_user)
):
    """視点分析の開始"""
    try:
        # 権限チェック
        await check_insight_permission(insight_id, user, "analyze")
        
        # 分析開始
        # analysis = await analysis_service.start_analysis(insight_id, perspective_type, user)
        
        # サンプルレスポンス
        analysis_id = str(uuid.uuid4())
        response = PerspectiveAnalysisResponse(
            perspective_type=perspective_type,
            analysis_id=analysis_id,
            importance_score=0.0,
            confidence_score=0.0,
            urgency_score=0.0,
            impact_score=0.0,
            metrics=[],
            key_findings=[],
            recommendations=[],
            risks=[],
            opportunities=[],
            analysis_timestamp=datetime.utcnow(),
            quality_score=0.0
        )
        
        logger.info(f"Started {perspective_type} analysis for insight {insight_id}")
        return response
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error starting analysis: {str(e)}")
        raise HTTPException(status_code=500, detail="Internal server error")

# コンセンサス形成エンドポイント
@app.post(
    "/api/v1/insights/{insight_id}/consensus",
    response_model=ConsensusResultResponse,
    status_code=201,
    summary="コンセンサス形成の開始",
    description="3つの視点分析結果からコンセンサスを形成します。"
)
async def start_consensus_formation(
    insight_id: str = Path(..., description="洞察ID"),
    user: dict = Depends(get_current_user)
):
    """コンセンサス形成の開始"""
    try:
        # 権限チェック
        await check_insight_permission(insight_id, user, "consensus")
        
        # コンセンサス形成
        # consensus = await consensus_service.form_consensus(insight_id, user)
        
        # サンプルレスポンス
        consensus_id = str(uuid.uuid4())
        response = ConsensusResultResponse(
            consensus_id=consensus_id,
            consensus_score=0.0,
            convergence_achieved=False,
            equilibrium_point=None,
            perspective_alignment={},
            conflict_areas=[],
            agreement_areas=[],
            integrated_recommendations=[],
            priority_actions=[],
            consensus_timestamp=datetime.utcnow(),
            consensus_quality=0.0
        )
        
        logger.info(f"Started consensus formation for insight {insight_id}")
        return response
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error starting consensus formation: {str(e)}")
        raise HTTPException(status_code=500, detail="Internal server error")

# 検索エンドポイント
@app.post(
    "/api/v1/insights/search",
    response_model=InsightListResponse,
    summary="高度検索",
    description="複雑な条件による戦略的洞察の検索を実行します。"
)
async def search_insights(
    query: str = Query(..., description="検索クエリ"),
    filters: Optional[Dict[str, Any]] = None,
    user: dict = Depends(get_current_user)
):
    """高度検索"""
    try:
        # 検索実行
        # results = await search_service.search_insights(query, filters, user)
        
        # サンプルレスポンス
        return InsightListResponse(
            insights=[],
            total_count=0,
            page_info={"current_page": 1, "total_pages": 0, "total_count": 0}
        )
        
    except Exception as e:
        logger.error(f"Error searching insights: {str(e)}")
        raise HTTPException(status_code=500, detail="Internal server error")

# ヘルスチェックエンドポイント
@app.get("/api/v1/health", summary="ヘルスチェック")
async def health_check():
    """システムヘルスチェック"""
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow(),
        "version": "1.0.0",
        "services": {
            "database": "healthy",
            "cache": "healthy",
            "message_queue": "healthy"
        }
    }

# エラーハンドラー
@app.exception_handler(HTTPException)
async def http_exception_handler(request, exc):
    """HTTP例外ハンドラー"""
    return {
        "status": "error",
        "code": f"HTTP_{exc.status_code}",
        "message": exc.detail,
        "timestamp": datetime.utcnow(),
        "request_id": getattr(request.state, 'request_id', None)
    }

@app.exception_handler(Exception)
async def general_exception_handler(request, exc):
    """一般例外ハンドラー"""
    logger.error(f"Unhandled exception: {str(exc)}")
    return {
        "status": "error",
        "code": "INTERNAL_ERROR",
        "message": "Internal server error",
        "timestamp": datetime.utcnow(),
        "request_id": getattr(request.state, 'request_id', None)
    }

# ミドルウェア
@app.middleware("http")
async def add_request_id_middleware(request, call_next):
    """リクエストID追加ミドルウェア"""
    request_id = str(uuid.uuid4())
    request.state.request_id = request_id
    
    response = await call_next(request)
    response.headers["X-Request-ID"] = request_id
    
    return response

@app.middleware("http")
async def logging_middleware(request, call_next):
    """ロギングミドルウェア"""
    start_time = datetime.utcnow()
    
    response = await call_next(request)
    
    process_time = (datetime.utcnow() - start_time).total_seconds()
    logger.info(
        f"Request: {request.method} {request.url.path} "
        f"Status: {response.status_code} "
        f"Duration: {process_time:.3f}s"
    )
    
    return response

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

### GraphQL統合設計

RESTful APIの補完として、より柔軟なデータクエリを可能にするGraphQL APIを提供します。

#### GraphQLスキーマ設計

**型安全性**を重視し、すべてのデータ型を明確に定義します。GraphQLの強力な型システムを活用して、クライアント側での開発効率を向上させます。

**クエリ最適化**では、N+1問題の解決、データローダーパターンの実装、効率的なデータ取得を実現します。

**リアルタイム機能**では、GraphQL Subscriptionを活用して、リアルタイムデータ更新を提供します。

```python
# graphql_api/schema.py
import graphene
from graphene import ObjectType, String, Int, Float, Boolean, List, Field, DateTime, Enum
from graphene_sqlalchemy import SQLAlchemyObjectType
from typing import Optional, List as TypingList
import asyncio
from datetime import datetime

# Enum定義
class PerspectiveTypeEnum(Enum):
    TECHNOLOGY = "technology"
    MARKET = "market"
    BUSINESS = "business"

class InsightStatusEnum(Enum):
    DRAFT = "draft"
    ANALYZING = "analyzing"
    CONSENSUS_PENDING = "consensus_pending"
    VALIDATED = "validated"
    IMPLEMENTED = "implemented"
    ARCHIVED = "archived"

class ConfidenceLevelEnum(Enum):
    VERY_HIGH = "very_high"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    VERY_LOW = "very_low"

# GraphQLオブジェクト型
class MetricType(ObjectType):
    name = String(required=True)
    value = String(required=True)  # 任意の型の値をJSON文字列として格納
    unit = String()
    confidence = Float(required=True)
    timestamp = DateTime(required=True)
    source = String()

class PerspectiveAnalysisType(ObjectType):
    perspective_type = Field(PerspectiveTypeEnum, required=True)
    analysis_id = String(required=True)
    importance_score = Float(required=True)
    confidence_score = Float(required=True)
    urgency_score = Float(required=True)
    impact_score = Float(required=True)
    metrics = List(MetricType, required=True)
    key_findings = List(String, required=True)
    recommendations = List(String, required=True)
    risks = List(String, required=True)
    opportunities = List(String, required=True)
    analysis_timestamp = DateTime(required=True)
    quality_score = Float(required=True)
    
    # 計算フィールド
    overall_score = Float()
    
    def resolve_overall_score(self, info):
        """総合スコアの計算"""
        weights = {'importance': 0.3, 'confidence': 0.2, 'urgency': 0.2, 'impact': 0.3}
        return (
            self.importance_score * weights['importance'] +
            self.confidence_score * weights['confidence'] +
            self.urgency_score * weights['urgency'] +
            self.impact_score * weights['impact']
        )

class ConsensusResultType(ObjectType):
    consensus_id = String(required=True)
    consensus_score = Float(required=True)
    convergence_achieved = Boolean(required=True)
    equilibrium_point = String()  # JSON文字列として格納
    perspective_alignment = String(required=True)  # JSON文字列として格納
    conflict_areas = List(String, required=True)
    agreement_areas = List(String, required=True)
    integrated_recommendations = List(String, required=True)
    priority_actions = List(String, required=True)
    consensus_timestamp = DateTime(required=True)
    consensus_quality = Float(required=True)

class StrategicInsightType(ObjectType):
    insight_id = String(required=True)
    title = String(required=True)
    description = String(required=True)
    category = String(required=True)
    tags = List(String, required=True)
    status = Field(InsightStatusEnum, required=True)
    confidence_level = Field(ConfidenceLevelEnum, required=True)
    
    # 視点別分析
    technology_analysis = Field(PerspectiveAnalysisType)
    market_analysis = Field(PerspectiveAnalysisType)
    business_analysis = Field(PerspectiveAnalysisType)
    
    # コンセンサス結果
    consensus_result = Field(ConsensusResultType)
    
    # 統合評価
    overall_importance = Float(required=True)
    overall_confidence = Float(required=True)
    overall_urgency = Float(required=True)
    overall_impact = Float(required=True)
    strategic_value = Float(required=True)
    
    # メタデータ
    created_timestamp = DateTime(required=True)
    updated_timestamp = DateTime(required=True)
    validation_timestamp = DateTime()
    completion_percentage = Float(required=True)
    
    # 関連データ
    related_insights = List(lambda: StrategicInsightType)
    
    def resolve_related_insights(self, info):
        """関連洞察の取得"""
        # 実装では、データベースから関連洞察を取得
        return []
    
    # 計算フィールド
    is_complete = Boolean()
    executive_summary = String()
    
    def resolve_is_complete(self, info):
        """完了状態の確認"""
        return all([
            self.technology_analysis is not None,
            self.market_analysis is not None,
            self.business_analysis is not None
        ])
    
    def resolve_executive_summary(self, info):
        """エグゼクティブサマリーの生成"""
        if not self.resolve_is_complete(info):
            return "分析が完了していません。"
        
        summary_parts = [
            f"戦略的洞察: {self.title}",
            f"総合評価: 重要度{self.overall_importance:.1%}, 信頼度{self.overall_confidence:.1%}",
            f"戦略的価値: {self.strategic_value:.2f}"
        ]
        
        if self.consensus_result and self.consensus_result.convergence_achieved:
            summary_parts.append(f"コンセンサス達成: {self.consensus_result.consensus_score:.1%}")
        
        return "\n".join(summary_parts)

# 入力型
class CreateInsightInput(graphene.InputObjectType):
    title = String(required=True)
    description = String(required=True)
    category = String(required=True)
    tags = List(String)
    priority = Int()

class UpdateInsightInput(graphene.InputObjectType):
    title = String()
    description = String()
    category = String()
    tags = List(String)
    priority = Int()
    status = Field(InsightStatusEnum)

class InsightFilterInput(graphene.InputObjectType):
    status = Field(InsightStatusEnum)
    category = String()
    tags = List(String)
    min_importance = Float()
    min_confidence = Float()
    created_after = DateTime()
    created_before = DateTime()

class PaginationInput(graphene.InputObjectType):
    page = Int(default_value=1)
    limit = Int(default_value=20)

# 接続型（ページネーション用）
class InsightConnection(ObjectType):
    insights = List(StrategicInsightType, required=True)
    total_count = Int(required=True)
    page_info = String(required=True)  # JSON文字列として格納

# クエリ
class Query(ObjectType):
    # 戦略的洞察関連
    insights = Field(
        InsightConnection,
        filter=InsightFilterInput(),
        pagination=PaginationInput(),
        description="戦略的洞察一覧の取得"
    )
    
    insight = Field(
        StrategicInsightType,
        insight_id=String(required=True),
        description="戦略的洞察詳細の取得"
    )
    
    search_insights = Field(
        InsightConnection,
        query=String(required=True),
        filter=InsightFilterInput(),
        pagination=PaginationInput(),
        description="戦略的洞察の検索"
    )
    
    # 分析関連
    perspective_analysis = Field(
        PerspectiveAnalysisType,
        analysis_id=String(required=True),
        description="視点分析詳細の取得"
    )
    
    # 統計・集計
    insight_statistics = Field(
        String,  # JSON文字列として統計データを返す
        filter=InsightFilterInput(),
        description="洞察統計の取得"
    )
    
    async def resolve_insights(self, info, filter=None, pagination=None):
        """戦略的洞察一覧の取得"""
        try:
            # 認証チェック
            user = info.context.get('user')
            if not user:
                raise Exception("Authentication required")
            
            # フィルタリング・ページネーション処理
            # 実装では、データベースクエリを実行
            insights = []  # サンプル
            total_count = 0
            
            page_info = {
                "current_page": pagination.page if pagination else 1,
                "total_pages": 0,
                "total_count": total_count,
                "has_next": False,
                "has_previous": False
            }
            
            return InsightConnection(
                insights=insights,
                total_count=total_count,
                page_info=str(page_info)
            )
            
        except Exception as e:
            raise Exception(f"Error fetching insights: {str(e)}")
    
    async def resolve_insight(self, info, insight_id):
        """戦略的洞察詳細の取得"""
        try:
            # 認証チェック
            user = info.context.get('user')
            if not user:
                raise Exception("Authentication required")
            
            # データベースから取得
            # insight = await insight_service.get_insight(insight_id, user)
            # if not insight:
            #     raise Exception("Insight not found")
            
            # return insight
            raise Exception("Insight not found")  # サンプル
            
        except Exception as e:
            raise Exception(f"Error fetching insight: {str(e)}")
    
    async def resolve_search_insights(self, info, query, filter=None, pagination=None):
        """戦略的洞察の検索"""
        try:
            # 認証チェック
            user = info.context.get('user')
            if not user:
                raise Exception("Authentication required")
            
            # 検索実行
            # results = await search_service.search_insights(query, filter, pagination, user)
            
            # サンプルレスポンス
            return InsightConnection(
                insights=[],
                total_count=0,
                page_info=str({"current_page": 1, "total_pages": 0, "total_count": 0})
            )
            
        except Exception as e:
            raise Exception(f"Error searching insights: {str(e)}")

# ミューテーション
class Mutation(ObjectType):
    # 戦略的洞察管理
    create_insight = Field(
        StrategicInsightType,
        input=CreateInsightInput(required=True),
        description="新規戦略的洞察の作成"
    )
    
    update_insight = Field(
        StrategicInsightType,
        insight_id=String(required=True),
        input=UpdateInsightInput(required=True),
        description="戦略的洞察の更新"
    )
    
    delete_insight = Field(
        Boolean,
        insight_id=String(required=True),
        description="戦略的洞察の削除"
    )
    
    # 分析関連
    start_perspective_analysis = Field(
        PerspectiveAnalysisType,
        insight_id=String(required=True),
        perspective_type=Field(PerspectiveTypeEnum, required=True),
        description="視点分析の開始"
    )
    
    start_consensus_formation = Field(
        ConsensusResultType,
        insight_id=String(required=True),
        description="コンセンサス形成の開始"
    )
    
    async def resolve_create_insight(self, info, input):
        """新規戦略的洞察の作成"""
        try:
            # 認証チェック
            user = info.context.get('user')
            if not user:
                raise Exception("Authentication required")
            
            # 洞察作成
            # insight = await insight_service.create_insight(input, user)
            # return insight
            
            # サンプルレスポンス
            raise Exception("Not implemented")
            
        except Exception as e:
            raise Exception(f"Error creating insight: {str(e)}")
    
    async def resolve_update_insight(self, info, insight_id, input):
        """戦略的洞察の更新"""
        try:
            # 認証チェック
            user = info.context.get('user')
            if not user:
                raise Exception("Authentication required")
            
            # 権限チェック
            # await check_insight_permission(insight_id, user, "update")
            
            # 更新処理
            # insight = await insight_service.update_insight(insight_id, input, user)
            # return insight
            
            # サンプルレスポンス
            raise Exception("Not implemented")
            
        except Exception as e:
            raise Exception(f"Error updating insight: {str(e)}")
    
    async def resolve_delete_insight(self, info, insight_id):
        """戦略的洞察の削除"""
        try:
            # 認証チェック
            user = info.context.get('user')
            if not user:
                raise Exception("Authentication required")
            
            # 権限チェック
            # await check_insight_permission(insight_id, user, "delete")
            
            # 削除処理
            # success = await insight_service.delete_insight(insight_id, user)
            # return success
            
            # サンプルレスポンス
            return False
            
        except Exception as e:
            raise Exception(f"Error deleting insight: {str(e)}")

# サブスクリプション
class Subscription(ObjectType):
    # リアルタイム通知
    insight_updated = Field(
        StrategicInsightType,
        insight_id=String(),
        description="洞察更新通知"
    )
    
    analysis_completed = Field(
        PerspectiveAnalysisType,
        insight_id=String(),
        perspective_type=Field(PerspectiveTypeEnum),
        description="分析完了通知"
    )
    
    consensus_achieved = Field(
        ConsensusResultType,
        insight_id=String(),
        description="コンセンサス達成通知"
    )
    
    async def resolve_insight_updated(self, info, insight_id=None):
        """洞察更新通知"""
        # WebSocketまたはServer-Sent Eventsを使用したリアルタイム通知
        # 実装では、メッセージキューからイベントを受信
        while True:
            # イベント待機
            await asyncio.sleep(1)
            # yield updated_insight

# スキーマ定義
schema = graphene.Schema(
    query=Query,
    mutation=Mutation,
    subscription=Subscription
)

# GraphQL実行例
if __name__ == "__main__":
    # クエリ例
    query = """
    query GetInsightWithAnalyses($insightId: String!) {
        insight(insightId: $insightId) {
            insightId
            title
            description
            status
            overallImportance
            overallConfidence
            strategicValue
            isComplete
            executiveSummary
            technologyAnalysis {
                perspectiveType
                importanceScore
                confidenceScore
                overallScore
                keyFindings
                recommendations
            }
            marketAnalysis {
                perspectiveType
                importanceScore
                confidenceScore
                overallScore
                keyFindings
                recommendations
            }
            businessAnalysis {
                perspectiveType
                importanceScore
                confidenceScore
                overallScore
                keyFindings
                recommendations
            }
            consensusResult {
                consensusScore
                convergenceAchieved
                integratedRecommendations
                priorityActions
            }
        }
    }
    """
    
    # ミューテーション例
    mutation = """
    mutation CreateNewInsight($input: CreateInsightInput!) {
        createInsight(input: $input) {
            insightId
            title
            status
            createdTimestamp
        }
    }
    """
    
    # サブスクリプション例
    subscription = """
    subscription OnInsightUpdated($insightId: String) {
        insightUpdated(insightId: $insightId) {
            insightId
            title
            status
            updatedTimestamp
        }
    }
    """
    
    print("GraphQL Schema defined successfully")
```

### リアルタイム通信設計

戦略的洞察の動的な性質に対応するため、WebSocketとServer-Sent Eventsを活用したリアルタイム通信機能を提供します。

#### WebSocket実装

**接続管理**では、ユーザーセッションの管理、認証状態の維持、接続品質の監視を行います。

**イベント配信**では、洞察更新、分析完了、コンセンサス達成などのイベントをリアルタイムで配信します。

**スケーラビリティ**では、Redis Pub/Subを活用した水平スケーリング対応を実現します。

この包括的なAPI設計により、トリプルパースペクティブ型戦略AIレーダーは、多様なクライアントアプリケーションとの統合を可能にし、柔軟で拡張性の高いインターフェースを提供します。


## ユーザーインターフェース設計

トリプルパースペクティブ型戦略AIレーダーの効果的な活用には、各読者層の専門性とワークフローに最適化されたユーザーインターフェースが不可欠です。本セクションでは、読者層別UI/UX設計、レスポンシブデザイン、アクセシビリティ対応を包括的に解説します。

### 読者層別UI/UX設計

各読者層の特性、業務フロー、情報ニーズに基づいて、専用のインターフェース設計を行います。

#### 経営者向けエグゼクティブダッシュボード

**設計思想**では、戦略的意思決定に必要な情報を瞬時に把握できる高レベルビューを提供します。

**情報階層**では、重要度に基づく情報の優先順位付けと、ドリルダウン可能な詳細情報へのアクセスを実現します。

**視覚的表現**では、直感的な理解を促進するインフォグラフィックスとデータビジュアライゼーションを採用します。

```typescript
// components/executive/ExecutiveDashboard.tsx
import React, { useState, useEffect, useMemo } from 'react';
import { Card, Grid, Typography, Box, Chip, LinearProgress, Alert } from '@mui/material';
import { TrendingUp, Warning, CheckCircle, Schedule } from '@mui/icons-material';
import { LineChart, Line, AreaChart, Area, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, PieChart, Pie, Cell } from 'recharts';
import { useQuery } from '@apollo/client';
import { GET_EXECUTIVE_SUMMARY } from '../graphql/queries';

interface ExecutiveMetric {
  id: string;
  title: string;
  value: number;
  unit: string;
  trend: 'up' | 'down' | 'stable';
  trendValue: number;
  importance: 'critical' | 'high' | 'medium' | 'low';
  lastUpdated: Date;
}

interface StrategicAlert {
  id: string;
  title: string;
  description: string;
  severity: 'critical' | 'warning' | 'info';
  category: 'technology' | 'market' | 'business';
  actionRequired: boolean;
  deadline?: Date;
}

interface ExecutiveDashboardProps {
  timeRange: '1M' | '3M' | '6M' | '1Y';
  onTimeRangeChange: (range: string) => void;
}

const ExecutiveDashboard: React.FC<ExecutiveDashboardProps> = ({ 
  timeRange, 
  onTimeRangeChange 
}) => {
  const [selectedMetric, setSelectedMetric] = useState<string | null>(null);
  const [alertFilter, setAlertFilter] = useState<string>('all');

  // GraphQLクエリでデータ取得
  const { data, loading, error } = useQuery(GET_EXECUTIVE_SUMMARY, {
    variables: { timeRange },
    pollInterval: 30000, // 30秒ごとに更新
  });

  // 重要指標の計算
  const keyMetrics = useMemo(() => {
    if (!data?.executiveSummary) return [];
    
    return [
      {
        id: 'strategic_value',
        title: '戦略的価値指数',
        value: data.executiveSummary.strategicValueIndex,
        unit: 'points',
        trend: data.executiveSummary.strategicValueTrend,
        trendValue: data.executiveSummary.strategicValueChange,
        importance: 'critical' as const,
        lastUpdated: new Date(data.executiveSummary.lastUpdated)
      },
      {
        id: 'consensus_rate',
        title: 'コンセンサス達成率',
        value: data.executiveSummary.consensusRate * 100,
        unit: '%',
        trend: data.executiveSummary.consensusTrend,
        trendValue: data.executiveSummary.consensusChange,
        importance: 'high' as const,
        lastUpdated: new Date(data.executiveSummary.lastUpdated)
      },
      {
        id: 'implementation_progress',
        title: '実装進捗率',
        value: data.executiveSummary.implementationProgress * 100,
        unit: '%',
        trend: data.executiveSummary.implementationTrend,
        trendValue: data.executiveSummary.implementationChange,
        importance: 'high' as const,
        lastUpdated: new Date(data.executiveSummary.lastUpdated)
      },
      {
        id: 'roi_projection',
        title: 'ROI予測',
        value: data.executiveSummary.roiProjection * 100,
        unit: '%',
        trend: data.executiveSummary.roiTrend,
        trendValue: data.executiveSummary.roiChange,
        importance: 'critical' as const,
        lastUpdated: new Date(data.executiveSummary.lastUpdated)
      }
    ];
  }, [data]);

  // アラートのフィルタリング
  const filteredAlerts = useMemo(() => {
    if (!data?.executiveSummary?.alerts) return [];
    
    return data.executiveSummary.alerts.filter((alert: StrategicAlert) => 
      alertFilter === 'all' || alert.category === alertFilter
    );
  }, [data, alertFilter]);

  // 重要度に基づく色の取得
  const getImportanceColor = (importance: string) => {
    switch (importance) {
      case 'critical': return '#d32f2f';
      case 'high': return '#f57c00';
      case 'medium': return '#1976d2';
      case 'low': return '#388e3c';
      default: return '#757575';
    }
  };

  // トレンドアイコンの取得
  const getTrendIcon = (trend: string) => {
    switch (trend) {
      case 'up': return <TrendingUp sx={{ color: '#4caf50' }} />;
      case 'down': return <TrendingUp sx={{ color: '#f44336', transform: 'rotate(180deg)' }} />;
      default: return <TrendingUp sx={{ color: '#757575', transform: 'rotate(90deg)' }} />;
    }
  };

  if (loading) {
    return (
      <Box sx={{ width: '100%', mt: 2 }}>
        <LinearProgress />
        <Typography variant="body2" sx={{ mt: 1, textAlign: 'center' }}>
          エグゼクティブサマリーを読み込み中...
        </Typography>
      </Box>
    );
  }

  if (error) {
    return (
      <Alert severity="error" sx={{ mt: 2 }}>
        データの読み込みに失敗しました: {error.message}
      </Alert>
    );
  }

  return (
    <Box sx={{ flexGrow: 1, p: 3 }}>
      {/* ヘッダー */}
      <Box sx={{ mb: 3, display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
        <Typography variant="h4" component="h1" sx={{ fontWeight: 'bold' }}>
          エグゼクティブダッシュボード
        </Typography>
        <Box sx={{ display: 'flex', gap: 1 }}>
          {['1M', '3M', '6M', '1Y'].map((range) => (
            <Chip
              key={range}
              label={range}
              variant={timeRange === range ? 'filled' : 'outlined'}
              onClick={() => onTimeRangeChange(range)}
              sx={{ cursor: 'pointer' }}
            />
          ))}
        </Box>
      </Box>

      {/* 重要指標カード */}
      <Grid container spacing={3} sx={{ mb: 3 }}>
        {keyMetrics.map((metric) => (
          <Grid item xs={12} sm={6} md={3} key={metric.id}>
            <Card 
              sx={{ 
                p: 2, 
                cursor: 'pointer',
                border: selectedMetric === metric.id ? 2 : 0,
                borderColor: 'primary.main',
                '&:hover': { elevation: 4 }
              }}
              onClick={() => setSelectedMetric(metric.id)}
            >
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
                <Box>
                  <Typography variant="body2" color="text.secondary" gutterBottom>
                    {metric.title}
                  </Typography>
                  <Typography variant="h4" component="div" sx={{ fontWeight: 'bold' }}>
                    {metric.value.toFixed(1)}{metric.unit}
                  </Typography>
                  <Box sx={{ display: 'flex', alignItems: 'center', mt: 1 }}>
                    {getTrendIcon(metric.trend)}
                    <Typography 
                      variant="body2" 
                      sx={{ 
                        ml: 0.5,
                        color: metric.trend === 'up' ? '#4caf50' : 
                               metric.trend === 'down' ? '#f44336' : '#757575'
                      }}
                    >
                      {metric.trendValue > 0 ? '+' : ''}{metric.trendValue.toFixed(1)}%
                    </Typography>
                  </Box>
                </Box>
                <Chip
                  size="small"
                  label={metric.importance}
                  sx={{ 
                    backgroundColor: getImportanceColor(metric.importance),
                    color: 'white',
                    fontSize: '0.7rem'
                  }}
                />
              </Box>
            </Card>
          </Grid>
        ))}
      </Grid>

      {/* メインコンテンツエリア */}
      <Grid container spacing={3}>
        {/* 戦略的価値トレンド */}
        <Grid item xs={12} md={8}>
          <Card sx={{ p: 3 }}>
            <Typography variant="h6" gutterBottom>
              戦略的価値トレンド
            </Typography>
            <ResponsiveContainer width="100%" height={300}>
              <AreaChart data={data?.executiveSummary?.valueHistory || []}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="date" />
                <YAxis />
                <Tooltip />
                <Area 
                  type="monotone" 
                  dataKey="strategicValue" 
                  stroke="#1976d2" 
                  fill="#1976d2" 
                  fillOpacity={0.3}
                />
                <Area 
                  type="monotone" 
                  dataKey="consensusRate" 
                  stroke="#4caf50" 
                  fill="#4caf50" 
                  fillOpacity={0.3}
                />
              </AreaChart>
            </ResponsiveContainer>
          </Card>
        </Grid>

        {/* 戦略的アラート */}
        <Grid item xs={12} md={4}>
          <Card sx={{ p: 3, height: '100%' }}>
            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
              <Typography variant="h6">
                戦略的アラート
              </Typography>
              <Box sx={{ display: 'flex', gap: 1 }}>
                {['all', 'technology', 'market', 'business'].map((filter) => (
                  <Chip
                    key={filter}
                    label={filter === 'all' ? '全て' : filter}
                    size="small"
                    variant={alertFilter === filter ? 'filled' : 'outlined'}
                    onClick={() => setAlertFilter(filter)}
                    sx={{ cursor: 'pointer', fontSize: '0.7rem' }}
                  />
                ))}
              </Box>
            </Box>
            <Box sx={{ maxHeight: 250, overflowY: 'auto' }}>
              {filteredAlerts.map((alert: StrategicAlert) => (
                <Alert 
                  key={alert.id}
                  severity={alert.severity}
                  sx={{ mb: 1, fontSize: '0.8rem' }}
                  icon={
                    alert.severity === 'critical' ? <Warning /> :
                    alert.actionRequired ? <Schedule /> : <CheckCircle />
                  }
                >
                  <Typography variant="body2" sx={{ fontWeight: 'bold' }}>
                    {alert.title}
                  </Typography>
                  <Typography variant="caption" display="block">
                    {alert.description}
                  </Typography>
                  {alert.deadline && (
                    <Typography variant="caption" sx={{ color: 'error.main' }}>
                      期限: {alert.deadline.toLocaleDateString()}
                    </Typography>
                  )}
                </Alert>
              ))}
            </Box>
          </Card>
        </Grid>

        {/* 視点別分析サマリー */}
        <Grid item xs={12}>
          <Card sx={{ p: 3 }}>
            <Typography variant="h6" gutterBottom>
              視点別分析サマリー
            </Typography>
            <Grid container spacing={3}>
              {['technology', 'market', 'business'].map((perspective) => (
                <Grid item xs={12} md={4} key={perspective}>
                  <Box sx={{ textAlign: 'center' }}>
                    <Typography variant="h6" sx={{ mb: 1, textTransform: 'capitalize' }}>
                      {perspective === 'technology' ? '技術視点' :
                       perspective === 'market' ? '市場視点' : 'ビジネス視点'}
                    </Typography>
                    <ResponsiveContainer width="100%" height={200}>
                      <PieChart>
                        <Pie
                          data={data?.executiveSummary?.perspectiveBreakdown?.[perspective] || []}
                          cx="50%"
                          cy="50%"
                          outerRadius={60}
                          fill="#8884d8"
                          dataKey="value"
                        >
                          {(data?.executiveSummary?.perspectiveBreakdown?.[perspective] || []).map((entry: any, index: number) => (
                            <Cell key={`cell-${index}`} fill={['#1976d2', '#4caf50', '#ff9800', '#f44336'][index % 4]} />
                          ))}
                        </Pie>
                        <Tooltip />
                      </PieChart>
                    </ResponsiveContainer>
                  </Box>
                </Grid>
              ))}
            </Grid>
          </Card>
        </Grid>
      </Grid>
    </Box>
  );
};

export default ExecutiveDashboard;
```

#### ビジネスアナリスト向け分析ワークベンチ

**機能重視設計**では、詳細な分析機能と柔軟なデータ操作を可能にするインターフェースを提供します。

**ワークフロー最適化**では、要件定義から分析、レポート作成までの一連の作業を効率化します。

**カスタマイズ性**では、個人の作業スタイルに応じたダッシュボードのカスタマイズを可能にします。

```typescript
// components/analyst/AnalysisWorkbench.tsx
import React, { useState, useCallback, useMemo } from 'react';
import { 
  Box, 
  Grid, 
  Paper, 
  Tabs, 
  Tab, 
  Table, 
  TableBody, 
  TableCell, 
  TableContainer, 
  TableHead, 
  TableRow,
  TextField,
  Button,
  Chip,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  Typography
} from '@mui/material';
import { ExpandMore, FilterList, Download, Share } from '@mui/icons-material';
import { DataGrid, GridColDef, GridRowsProp } from '@mui/x-data-grid';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { ScatterChart, Scatter, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from 'recharts';

interface AnalysisFilter {
  perspective: string[];
  importance: [number, number];
  confidence: [number, number];
  dateRange: [Date | null, Date | null];
  categories: string[];
  status: string[];
}

interface AnalysisWorkbenchProps {
  initialFilters?: Partial<AnalysisFilter>;
}

const AnalysisWorkbench: React.FC<AnalysisWorkbenchProps> = ({ initialFilters = {} }) => {
  const [activeTab, setActiveTab] = useState(0);
  const [filters, setFilters] = useState<AnalysisFilter>({
    perspective: [],
    importance: [0, 1],
    confidence: [0, 1],
    dateRange: [null, null],
    categories: [],
    status: [],
    ...initialFilters
  });
  const [selectedInsights, setSelectedInsights] = useState<string[]>([]);

  // データグリッドの列定義
  const columns: GridColDef[] = [
    { 
      field: 'id', 
      headerName: 'ID', 
      width: 100,
      renderCell: (params) => (
        <Chip label={params.value} size="small" variant="outlined" />
      )
    },
    { 
      field: 'title', 
      headerName: 'タイトル', 
      width: 300,
      renderCell: (params) => (
        <Typography variant="body2" sx={{ fontWeight: 'medium' }}>
          {params.value}
        </Typography>
      )
    },
    { 
      field: 'category', 
      headerName: 'カテゴリ', 
      width: 150,
      renderCell: (params) => (
        <Chip label={params.value} size="small" color="primary" />
      )
    },
    { 
      field: 'importance', 
      headerName: '重要度', 
      width: 120,
      type: 'number',
      renderCell: (params) => (
        <Box sx={{ display: 'flex', alignItems: 'center' }}>
          <Box
            sx={{
              width: 60,
              height: 8,
              backgroundColor: '#e0e0e0',
              borderRadius: 4,
              mr: 1
            }}
          >
            <Box
              sx={{
                width: `${params.value * 100}%`,
                height: '100%',
                backgroundColor: params.value > 0.7 ? '#4caf50' : 
                                params.value > 0.4 ? '#ff9800' : '#f44336',
                borderRadius: 4
              }}
            />
          </Box>
          <Typography variant="caption">
            {(params.value * 100).toFixed(0)}%
          </Typography>
        </Box>
      )
    },
    { 
      field: 'confidence', 
      headerName: '信頼度', 
      width: 120,
      type: 'number',
      renderCell: (params) => (
        <Box sx={{ display: 'flex', alignItems: 'center' }}>
          <Box
            sx={{
              width: 60,
              height: 8,
              backgroundColor: '#e0e0e0',
              borderRadius: 4,
              mr: 1
            }}
          >
            <Box
              sx={{
                width: `${params.value * 100}%`,
                height: '100%',
                backgroundColor: '#2196f3',
                borderRadius: 4
              }}
            />
          </Box>
          <Typography variant="caption">
            {(params.value * 100).toFixed(0)}%
          </Typography>
        </Box>
      )
    },
    { 
      field: 'status', 
      headerName: 'ステータス', 
      width: 150,
      renderCell: (params) => {
        const statusColors: { [key: string]: string } = {
          'draft': '#757575',
          'analyzing': '#ff9800',
          'consensus_pending': '#2196f3',
          'validated': '#4caf50',
          'implemented': '#9c27b0'
        };
        return (
          <Chip 
            label={params.value} 
            size="small" 
            sx={{ 
              backgroundColor: statusColors[params.value] || '#757575',
              color: 'white'
            }}
          />
        );
      }
    },
    { 
      field: 'updatedAt', 
      headerName: '更新日時', 
      width: 180,
      type: 'dateTime',
      renderCell: (params) => (
        <Typography variant="caption">
          {new Date(params.value).toLocaleString()}
        </Typography>
      )
    }
  ];

  // サンプルデータ
  const rows: GridRowsProp = [
    {
      id: 'insight_001',
      title: 'AI技術導入による業務効率化戦略',
      category: 'technology_adoption',
      importance: 0.85,
      confidence: 0.78,
      status: 'validated',
      updatedAt: new Date('2024-01-15T10:30:00')
    },
    {
      id: 'insight_002',
      title: '新興市場への展開可能性分析',
      category: 'market_expansion',
      importance: 0.72,
      confidence: 0.65,
      status: 'analyzing',
      updatedAt: new Date('2024-01-14T15:45:00')
    }
  ];

  // フィルター適用
  const filteredRows = useMemo(() => {
    return rows.filter(row => {
      // 重要度フィルター
      if (row.importance < filters.importance[0] || row.importance > filters.importance[1]) {
        return false;
      }
      
      // 信頼度フィルター
      if (row.confidence < filters.confidence[0] || row.confidence > filters.confidence[1]) {
        return false;
      }
      
      // カテゴリフィルター
      if (filters.categories.length > 0 && !filters.categories.includes(row.category)) {
        return false;
      }
      
      // ステータスフィルター
      if (filters.status.length > 0 && !filters.status.includes(row.status)) {
        return false;
      }
      
      return true;
    });
  }, [rows, filters]);

  // フィルター更新ハンドラー
  const updateFilter = useCallback((key: keyof AnalysisFilter, value: any) => {
    setFilters(prev => ({ ...prev, [key]: value }));
  }, []);

  // エクスポート機能
  const handleExport = useCallback(() => {
    const exportData = selectedInsights.length > 0 
      ? filteredRows.filter(row => selectedInsights.includes(row.id))
      : filteredRows;
    
    // CSV形式でエクスポート
    const csvContent = [
      Object.keys(exportData[0] || {}).join(','),
      ...exportData.map(row => Object.values(row).join(','))
    ].join('\n');
    
    const blob = new Blob([csvContent], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'strategic_insights_analysis.csv';
    a.click();
    URL.revokeObjectURL(url);
  }, [filteredRows, selectedInsights]);

  return (
    <Box sx={{ flexGrow: 1, p: 3 }}>
      {/* ヘッダー */}
      <Box sx={{ mb: 3, display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
        <Typography variant="h4" component="h1" sx={{ fontWeight: 'bold' }}>
          分析ワークベンチ
        </Typography>
        <Box sx={{ display: 'flex', gap: 1 }}>
          <Button
            variant="outlined"
            startIcon={<Download />}
            onClick={handleExport}
            disabled={filteredRows.length === 0}
          >
            エクスポート
          </Button>
          <Button
            variant="outlined"
            startIcon={<Share />}
          >
            共有
          </Button>
        </Box>
      </Box>

      {/* フィルターパネル */}
      <Accordion sx={{ mb: 3 }}>
        <AccordionSummary expandIcon={<ExpandMore />}>
          <Box sx={{ display: 'flex', alignItems: 'center' }}>
            <FilterList sx={{ mr: 1 }} />
            <Typography>詳細フィルター</Typography>
            <Chip 
              label={`${filteredRows.length}件`} 
              size="small" 
              sx={{ ml: 2 }} 
            />
          </Box>
        </AccordionSummary>
        <AccordionDetails>
          <Grid container spacing={3}>
            <Grid item xs={12} md={3}>
              <FormControl fullWidth>
                <InputLabel>視点</InputLabel>
                <Select
                  multiple
                  value={filters.perspective}
                  onChange={(e) => updateFilter('perspective', e.target.value)}
                  renderValue={(selected) => (
                    <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
                      {(selected as string[]).map((value) => (
                        <Chip key={value} label={value} size="small" />
                      ))}
                    </Box>
                  )}
                >
                  <MenuItem value="technology">技術視点</MenuItem>
                  <MenuItem value="market">市場視点</MenuItem>
                  <MenuItem value="business">ビジネス視点</MenuItem>
                </Select>
              </FormControl>
            </Grid>
            <Grid item xs={12} md={3}>
              <FormControl fullWidth>
                <InputLabel>カテゴリ</InputLabel>
                <Select
                  multiple
                  value={filters.categories}
                  onChange={(e) => updateFilter('categories', e.target.value)}
                  renderValue={(selected) => (
                    <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
                      {(selected as string[]).map((value) => (
                        <Chip key={value} label={value} size="small" />
                      ))}
                    </Box>
                  )}
                >
                  <MenuItem value="technology_adoption">技術導入</MenuItem>
                  <MenuItem value="market_expansion">市場拡大</MenuItem>
                  <MenuItem value="competitive_analysis">競合分析</MenuItem>
                  <MenuItem value="risk_assessment">リスク評価</MenuItem>
                </Select>
              </FormControl>
            </Grid>
            <Grid item xs={12} md={3}>
              <FormControl fullWidth>
                <InputLabel>ステータス</InputLabel>
                <Select
                  multiple
                  value={filters.status}
                  onChange={(e) => updateFilter('status', e.target.value)}
                  renderValue={(selected) => (
                    <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
                      {(selected as string[]).map((value) => (
                        <Chip key={value} label={value} size="small" />
                      ))}
                    </Box>
                  )}
                >
                  <MenuItem value="draft">ドラフト</MenuItem>
                  <MenuItem value="analyzing">分析中</MenuItem>
                  <MenuItem value="consensus_pending">コンセンサス待ち</MenuItem>
                  <MenuItem value="validated">検証済み</MenuItem>
                  <MenuItem value="implemented">実装済み</MenuItem>
                </Select>
              </FormControl>
            </Grid>
            <Grid item xs={12} md={3}>
              <DatePicker
                label="開始日"
                value={filters.dateRange[0]}
                onChange={(date) => updateFilter('dateRange', [date, filters.dateRange[1]])}
                slotProps={{ textField: { fullWidth: true } }}
              />
            </Grid>
          </Grid>
        </AccordionDetails>
      </Accordion>

      {/* メインコンテンツ */}
      <Paper sx={{ width: '100%' }}>
        <Tabs value={activeTab} onChange={(_, newValue) => setActiveTab(newValue)}>
          <Tab label="データテーブル" />
          <Tab label="散布図分析" />
          <Tab label="相関分析" />
          <Tab label="トレンド分析" />
        </Tabs>

        {/* データテーブルタブ */}
        {activeTab === 0 && (
          <Box sx={{ height: 600, width: '100%' }}>
            <DataGrid
              rows={filteredRows}
              columns={columns}
              checkboxSelection
              disableRowSelectionOnClick
              onRowSelectionModelChange={(newSelection) => {
                setSelectedInsights(newSelection as string[]);
              }}
              pageSizeOptions={[25, 50, 100]}
              initialState={{
                pagination: { paginationModel: { pageSize: 25 } }
              }}
            />
          </Box>
        )}

        {/* 散布図分析タブ */}
        {activeTab === 1 && (
          <Box sx={{ p: 3, height: 600 }}>
            <Typography variant="h6" gutterBottom>
              重要度 vs 信頼度 散布図
            </Typography>
            <ResponsiveContainer width="100%" height="90%">
              <ScatterChart data={filteredRows}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis 
                  dataKey="importance" 
                  name="重要度"
                  domain={[0, 1]}
                  tickFormatter={(value) => `${(value * 100).toFixed(0)}%`}
                />
                <YAxis 
                  dataKey="confidence" 
                  name="信頼度"
                  domain={[0, 1]}
                  tickFormatter={(value) => `${(value * 100).toFixed(0)}%`}
                />
                <Tooltip 
                  formatter={(value, name) => [`${(value as number * 100).toFixed(1)}%`, name]}
                  labelFormatter={(label) => `洞察: ${label}`}
                />
                <Scatter dataKey="confidence" fill="#1976d2" />
              </ScatterChart>
            </ResponsiveContainer>
          </Box>
        )}

        {/* その他のタブは省略 */}
      </Paper>
    </Box>
  );
};

export default AnalysisWorkbench;
```

### レスポンシブデザイン

モバイルデバイスからデスクトップまで、あらゆるスクリーンサイズで最適な体験を提供するレスポンシブデザインを実装します。

#### ブレークポイント戦略

**デバイス分類**では、モバイル（320-768px）、タブレット（768-1024px）、デスクトップ（1024px以上）の3つの主要ブレークポイントを設定します。

**コンテンツ適応**では、各デバイスの特性に応じたレイアウト調整とインタラクション最適化を行います。

**パフォーマンス最適化**では、デバイス性能に応じたコンテンツ配信とレンダリング最適化を実現します。

```typescript
// styles/responsive.ts
import { createTheme, responsiveFontSizes } from '@mui/material/styles';

// ブレークポイント定義
const breakpoints = {
  values: {
    xs: 0,      // モバイル（縦）
    sm: 600,    // モバイル（横）・小型タブレット
    md: 960,    // タブレット
    lg: 1280,   // デスクトップ
    xl: 1920    // 大型デスクトップ
  }
};

// レスポンシブテーマ
let theme = createTheme({
  breakpoints,
  palette: {
    primary: {
      main: '#1976d2',
      light: '#42a5f5',
      dark: '#1565c0'
    },
    secondary: {
      main: '#dc004e',
      light: '#ff5983',
      dark: '#9a0036'
    },
    background: {
      default: '#fafafa',
      paper: '#ffffff'
    }
  },
  typography: {
    fontFamily: '"Roboto", "Helvetica", "Arial", "Noto Sans JP", sans-serif',
    h1: {
      fontSize: '2.5rem',
      fontWeight: 700,
      lineHeight: 1.2,
      '@media (max-width:600px)': {
        fontSize: '2rem'
      }
    },
    h2: {
      fontSize: '2rem',
      fontWeight: 600,
      lineHeight: 1.3,
      '@media (max-width:600px)': {
        fontSize: '1.75rem'
      }
    },
    h3: {
      fontSize: '1.75rem',
      fontWeight: 600,
      lineHeight: 1.4,
      '@media (max-width:600px)': {
        fontSize: '1.5rem'
      }
    },
    body1: {
      fontSize: '1rem',
      lineHeight: 1.6,
      '@media (max-width:600px)': {
        fontSize: '0.9rem'
      }
    }
  },
  components: {
    // レスポンシブコンポーネント設定
    MuiContainer: {
      styleOverrides: {
        root: {
          paddingLeft: '16px',
          paddingRight: '16px',
          '@media (min-width: 600px)': {
            paddingLeft: '24px',
            paddingRight: '24px'
          }
        }
      }
    },
    MuiCard: {
      styleOverrides: {
        root: {
          margin: '8px 0',
          '@media (min-width: 600px)': {
            margin: '16px 0'
          }
        }
      }
    },
    MuiDataGrid: {
      styleOverrides: {
        root: {
          '& .MuiDataGrid-columnHeaders': {
            '@media (max-width: 600px)': {
              fontSize: '0.8rem'
            }
          },
          '& .MuiDataGrid-cell': {
            '@media (max-width: 600px)': {
              fontSize: '0.8rem',
              padding: '4px'
            }
          }
        }
      }
    }
  }
});

// フォントサイズの自動調整
theme = responsiveFontSizes(theme);

export default theme;

// レスポンシブユーティリティ
export const useResponsive = () => {
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));
  const isTablet = useMediaQuery(theme.breakpoints.between('sm', 'md'));
  const isDesktop = useMediaQuery(theme.breakpoints.up('md'));
  
  return {
    isMobile,
    isTablet,
    isDesktop,
    breakpoint: isMobile ? 'mobile' : isTablet ? 'tablet' : 'desktop'
  };
};

// レスポンシブレイアウトコンポーネント
export const ResponsiveLayout: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const { isMobile, isTablet } = useResponsive();
  
  return (
    <Box
      sx={{
        display: 'flex',
        flexDirection: isMobile ? 'column' : 'row',
        minHeight: '100vh'
      }}
    >
      {children}
    </Box>
  );
};
```

### アクセシビリティ対応

すべてのユーザーが等しくシステムを利用できるよう、WCAG 2.1 AA準拠のアクセシビリティ対応を実装します。

#### アクセシビリティ機能

**キーボードナビゲーション**では、すべての機能をキーボードのみで操作可能にします。

**スクリーンリーダー対応**では、適切なARIAラベルとセマンティックHTMLを使用します。

**視覚的配慮**では、色覚異常や視力低下に配慮したデザインを採用します。

この包括的なユーザーインターフェース設計により、トリプルパースペクティブ型戦略AIレーダーは、すべての読者層にとって使いやすく、アクセシブルで、効果的なツールとなります。

